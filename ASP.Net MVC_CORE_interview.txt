What is Asp.Net MVC Core?
Open Source Cross Platform(WINDOWS,LINUX,MAC) web development framework to develop web application created by Microsoft
NOTE:
2003: Asp.Net Web forms, 2009: Asp.Net MVC 5 , 2017: Asp.Net MVC Core
----------------------------------
dotNetCore vs dotNet Framework:
.NET Core is the latest version of Microsoft’s .NET Framework which is a free, open-source, general-purpose programming platform. It’s a cross-platform framework that works with Windows, Mac OS X, and Linux.The.NET Core Framework may be used to create a variety of apps, including mobile, desktop, online, cloud, IoT, machine learning, microservices, games, and more. .NET Core is written from scratch to make it a modular, lightweight, fast, and cross-platform Framework.

What is .NET Framework?
THE FRAMEWORK IS A REUSABLE DESIGN PLATFORM FOR SOFTWARE SYSTEMS, WHICH PROVIDES SUPPORT FOR CODE LIBRARIES AND VARIOUS SCRIPTING LANGUAGES IN SIMPLE WORDS A FRAMEWORK IS SOMETHING THAT MAKES CORE PROGRAMMING EASY. Microsoft’s Net Framework is a software development platform for building and running Windows applications.NET FRAMEWORK INCLUDES DEVELOPER TOOLS, PROGRAMMING LANGUAGES, AND LIBRARIES THAT ARE USED TO DEVELOP DESKTOP AND WEB APPLICATIONS. It is also used to build websites, web services, and games.

The Dot Net Framework was designed to let developers construct programs that would operate on Microsoft’s Windows platform and dot net framework applications are multi-platform applications. The framework has been decided in such a way that it can be used from any of the following languages: c#, c++, Visual Basic, JScript, COBOL, etc. In the year 2002, the initial version of the dot Net framework was launched. Dot Net Framework 1.0 was the name of the version. Since then, the Microsoft dot Net framework has evolved significantly, and the most recent version is dot Net Framework 4.7.2(6.0 stable and 7.0 latest) that is released on April 30, 2018.

Key Differences
Now we have a complete idea about what .NET Core and .NET Framework are. so let’s go through the key differences between .NET Core and .NET Framework. 
Basically, Microsoft .NET Core is a free, open-source, general-purpose development platform to build cloud-based software applications on Windows, Linux, and macOS 
whereas  
Microsoft’s .Net Framework is a software development platform for building and running Windows applications.Net framework that includes developer tools, programming languages, and libraries that are used to develop desktop and web applications.
		The key difference between .NET Core and .NET Framework is that one(.Net Framework) is a platform for .NET applications on Windows whereas, NET Core is the latest version of the .NET Framework which is a cross-platform and open-source framework optimized for modern app needs and developer workflows
----------------------------------
There are four major components of the .NET architecture:

1.Common language specification (CLS) defines how objects are implemented, in a way that they can work everywhere .NET works. CLS is a subset of the Common Type System (CTS), which sets common ways to describe all types.
2.Framework class library (FCL) is a standard library that collects reusable classes, interfaces, and value types.
3.Common language runtime (CLR) is the virtual machine that runs the framework and manages the execution of .NET programs.
4.Visual Studio is the IDE, provided also by Microsoft, to create entire projects and standalone applications, interactive websites, and web services.


CLR:
Common Language Runtime
CLR is the basic and VIRTUAL MACHINE component of the .NET Framework. It is the RUN-TIME ENVIRONMENT in the .NET Framework that runs the codes and helps in making the development process easier by providing the various services. PARTS: CLS and CTS

Basically, IT IS RESPONSIBLE FOR MANAGING THE EXECUTION OF .NET PROGRAMS REGARDLESS OF ANY .NET PROGRAMMING LANGUAGE. Internally, CLR implements the VES(Virtual Execution System) which is defined in the Microsoft’s implementation of the CLI(Common Language Infrastructure)

Suppose you have written a C# program and save it in a file which is known as the Source Code.
Language specific compiler compiles the source code into the MSIL(Microsoft Intermediate Language) which is also known as the CIL(Common Intermediate Language) or IL(Intermediate Language) along with its metadata. Metadata includes all the types, actual implementation of each function of the program. MSIL is machine-independent code

Now CLR comes into existence. CLR provides the services and runtime environment to the MSIL code. Internally CLR includes the JIT(Just-In-Time) compiler which converts the MSIL code to MACHINE CODE which further executed by CPU

What is current project assembly in C#?:
An assembly is a file that is automatically generated by the compiler upon successful compilation of every .NET application. It can be either a Dynamic Link Library(.dll) or an executable file(.exe). It is generated only once for an application and upon each subsequent compilation the assembly gets updated

CLS vs CTS:CLS(Common Language Specification{ cross-language}) and CTS(Common Type System{datatypes}):
CTS and CLS are parts of .NET CLR and are responsible for type safety within the code. Both allow cross-language communication and type safety.

CLS:
CLS stands for Common Language Specification and it is a subset of CTS. It defines a set of rules and restrictions that every language must follow which runs under the .NET framework. The languages which follow these set of rules are said to be CLS Compliant. In simple words, CLS enables cross-language integration or Interoperability.

For Example

if we talk about C# and VB.NET then, in C# every statement must have to end with a semicolon. it is also called a statement Terminator, but in VB.NET each statement should not end with a semicolon(;).
Explanation of the above Example: So these syntax rules which you have to follow from language to language differ but CLR can understand all the language Syntax because in .NET each language is converted into MSIL code after compilation and the MSIL code is language specification of CLR.

CTS:
Common Type System (CTS) describes the datatypes that can be used by managed code. CTS defines how these types are declared, used and managed in the runtime. It facilitates cross-language integration, type safety, and high-performance code execution. The rules defined in CTS can be used to define your own classes and values.

OR we can also understand like,

CTS deals with the data type. So here we have several languages and each and every language has its own data type and one language data type cannot be understandable by other languages but .NET Framework language can understand all the data types.
C# has an int data type and VB.NET has Integer data type. Hence a variable declared as an int in C# and Integer in VB.NET, finally after compilation, uses the same structure Int32 from CTS.
----------------------------------
What is middleware:

Middleware are SOFTWARE COMPONENTS in an application used to HANDLE REQUESTS AND RESPONSES. It also controls the ERROR RESPONSES and plays an important role in user AUTHENTICATION AND AUTHORIZATION.  
Every part of Middleware is an object and is used for specific purposes. We need pieces of Middleware to make the application interface correct and smooth. It is also referred to as a series of components used in the PROCESSING PIPELINE to help in the authorization of users

Middleware is software that's assembled into an app pipeline to handle requests and responses. Each component:
Chooses whether to pass the request to the next component in the pipeline.
Can perform work before and after the next component in the pipeline.
Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.

Middleware is a piece of code in an application pipeline used to handle requests and responses.
For example, we may have a middleware component to authenticate a user, another piece of middleware to handle errors, and another middleware to serve static files such as JavaScript files, CSS files, images, etc.
Middleware can be built-in as part of the .NET Core framework, added via NuGet packages, or can be custom middleware. These middleware components are configured as part of the application startup class in the configure method. Configure methods set up a request processing pipeline for an ASP.NET Core application. It consists of a sequence of request delegates called one after the other

(app.)
Use — this method will EXECUTE THE DELEGATE AND THEN MOVE TO THE NEXT STEP in the pipeline. The Use method can also be used to short-circuit the pipeline.
Run — this method will EXECUTE A DELEGATE AND RETURN the result. at the end to run all the middlewares. 
Map — this method will EXECUTE A DELEGATE CONDITIONALLY AND RETURN the result.

next() to goto next middleware
app.Use(async (context, next) =>    
    {    
        await context.Response.WriteAsync("Before Invoke from 1st app.Use()\n");    
        await next();    
        await context.Response.WriteAsync("After Invoke from 1st app.Use()\n");    
    });    
    
app.Use(async (context, next) =>    
{    
	await context.Response.WriteAsync("Before Invoke from 2nd app.Use()\n");    
	await next();    
	await context.Response.WriteAsync("After Invoke from 2nd app.Use()\n");    
});    
	
app.Use()
 
This is used to CONFIGURE MULTIPLE MIDDLEWARE. Unlike app.Run(), We can include the NEXT parameter into it, which calls the next request delegate in the pipeline. We can also short-circuit (terminate) the pipeline by NOT CALLING THE NEXT PARAMETER

app.Run()
 
This middleware component may expose Run[Middleware] methods that are executed at the end of the pipeline. Generally, this acts as a TERMINAL MIDDLEWARE and is added at the END of the request pipeline, as it CANNOT CALL THE NEXT MIDDLEWARE.

app.Map()
The Map method Branches the request pipeline based on matches of the given request path. If the request path starts with the given path, the branch is executed

private static void MapRequestA(IApplicationBuilder app)
    {
        app.Run(async context =>
        {
            await context.Response.WriteAsync("This is MapRequestA");
        });
    }

app.Map("/mapRequestPathA", MapRequestA);
app.Map("/mapRequestPathB", MapRequestB);
app.Map("/mapRequestPathB", MapRequestC);
		
app.UseMiddlewareOne();

app.MapWhen(context => context.Request.Path.StartsWithSegments("/api"), appBuilder =>
{
    appBuilder.UseMiddlewareTwo();
});

app.UseMiddlewareThree();
//builder.UseMiddleware<MyMiddleware>(); when in another file and registering in program.cs
+++++++++++++
Middleware is simply the pipeline for handling web requests in ASP.NET Core. All ASP.NET Core applications NEED A MINIMUM OF ONE PIECE OF MIDDLEWARE to respond to requests and your applications are effectively just a collection of middleware. Even the MVC pipeline itself is middleware.
Each middleware component has an Invoke method with an HttpContext argument. You can use this argument to handle the request and generate a response if applicable:

public async Task Invoke(HttpContext context)
{
    if (context.Request.Path...)
    {
        await context.Response.WriteAsync("writing text...");
    }
}
Optionally, you can add other arguments to your Invoke method and these dependencies will be resolved on each request using the baked in dependency injection support (these dependencies would need to be registered in ConfigureServices):

public async Task Invoke(HttpContext context, MyOtherDependency blah)
{if (blah.DoSomething(context)){...}}
Middleware Execution
We'll learn how to configure the middleware pipeline in the next section but it is important to be aware that the order of registration determines the order of execution.

The top-most piece of middleware in your application will always get called for each request. This is done automatically by the framework. This middleware may send a response to the client (terminating the pipeline), or it may call the next piece of middleware. For the latter option, it of course needs access to the next middleware component.
This is why most middleware components are defined with a constructor that takes a RequestDelegate argument.

public class MyMiddleware
{
    private readonly RequestDelegate _next;
    
    public MyMiddleware(RequestDelegate next, OtherDependencies...)
    {
        _next = next;
    }
}
The RequestDelegate is populated automatically and gives you a reference to the next piece of middleware in the pipeline. We typically store the RequestDelegate so we can call it from the Invoke method which is where the middleware does its work.

THE FINAL CASE I WANT TO LOOK AT IS WHEN YOU WANT MOST OF YOUR MIDDLEWARE TO RUN FOR ALL REQUESTS BUT YOU HAVE SOME CONDITIONAL PIECES - SPECIFIC MIDDLEWARE THAT SHOULD ONLY RUN FOR CERTAIN REQUESTS.

Conditional middleware::

This is easily achieved with UseWhen which also uses a predicate to determine if the middleware should run:

ex:
app.UseWhen(context => context.Request.Path.StartsWithSegments("/api"), appBuilder =>
{
    appBuilder.UseStatusCodePagesWithReExecute("/apierror/{0}");

    appBuilder.UseExceptionHandler("/apierror/500");
});

ex:
app.UseWhen(context => context.Request.Query.ContainsKey("branch"), appBuilder => HandleBranchAndRejoin(appBuilder));
app.UseMiddlewareOne();

app.UseWhen(context => context.Request.Path.StartsWithSegments("/api"), appBuilder =>
{
    appBuilder.UseMiddlewareTwo();
});

The Invoke method in ASP.NET Core
Each middleware component contains an Invoke method. This method accepts a reference to an instance of HttpContext as an argument. A middleware component can perform operations before and after the next middleware component is called. Here is an example of a typical Invoke method:

public async Task Invoke(HttpContext context)
{
    // Write code here that will be executed before the
    // next middleware is called
        await _next.Invoke(context); // call next middleware
    // Write code here that will be executed after the
    //next middleware is called 
}

Branching the HTTP pipeline in ASP.NET Core
The Map extension methods, i.e. Map and MapWhen, are used for branching the pipeline. While Map is used to branch based on a given REQUEST PATH, MapWhen is used to branch based on the result of a given PREDICATE.

CUSTOM MIDDLEWARE:
The custom middleware component is like any other .NET class with Invoke() method. However, in order to execute next middleware in a sequence, it should have RequestDelegate type parameter in the constructor.

Visual Studio includes template for creating standard middleware class. For this, right click on the project or folder where you want to create middleware class and select Add -> New Item. This will open Add New Item popup. Search for word "middleware" in the top right search box as shown below.

Add Custom Middleware
Select Middleware Class item and give it a name and click on Add button. This will add a new class for the middleware with extension method as shown below.

Example: Custom Middleware
// You may need to install the Microsoft.AspNetCore.Http.Abstractions package into your project
public class MyMiddleware
{
    private readonly RequestDelegate _next;

    public MyMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public Task Invoke(HttpContext httpContext)
    {

        return _next(httpContext);
    }
}

// Extension method used to add the middleware to the HTTP request pipeline.
public static class MyMiddlewareExtensions
{
    public static IApplicationBuilder UseMyMiddleware(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<MyMiddleware>();
    }
} 
As you can see above, the Invoke() method is not asynchronous. So, change it to asynchronous and write your custom logic before calling next();

public class MyMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger _logger;

    public MyMiddleware(RequestDelegate next, ILoggerFactory logFactory)
    {
        _next = next;

        _logger = logFactory.CreateLogger("MyMiddleware");
    }

    public async Task Invoke(HttpContext httpContext)
    {
        _logger.LogInformation("MyMiddleware executing..");

        await _next(httpContext); // calling next middleware

    }
}

// Extension method used to add the middleware to the HTTP request pipeline.
public static class MyMiddlewareExtensions
{
    public static IApplicationBuilder UseMyMiddleware(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<MyMiddleware>();
    }
} 
Add Custom Middleware
Now, we need to add our custom middleware in the request pipeline by using Use extension method as shown below.

Example: Add Middleware into Request Pipeline Copy
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseMyMiddleware();

    app.Run(async (context) =>
    {
        await context.Response.WriteAsync("Hello World!");
    });
}
We can add middleware using app.UseMiddleware<MyMiddleware>() method of IApplicationBuilder also.
----------------------------------
UseWhen vs MapWhen:

The UseWhen method can be used to execute middleware conditionally. The following code snippet illustrates how the UseWhen method can be used to execute a middleware component if the request path starts with "/api".

app.UseWhen(context => context.Request.Path.StartsWithSegments("/api"), applicationBuilder =>
{
    applicationBuilder.UseCustomMiddleware();
});

Note:::::: that unlike MapWhen, the UseWhen method continues to execute the later middleware irrespective of whether the UseWhen predicate was true or false

Let’s understand this with an example. Consider the following piece of code:

app.UseMiddlewareA();
app.UseWhen(context => context.Request.Path.StartsWithSegments("/api"), applicationBuilder =>
{
    applicationBuilder.UseMiddlewareB();
});
app.UseMiddlewareC();

/*
app.MapWhen(context => context.Request.Path.StartsWithSegments("/api"), appBuilder =>
{
    appBuilder.UseMiddlewareTwo();
});
*/
If there is no short-circuiting of the middleware, middleware A and C will always be executed. Middleware B will be executed only if the request path starts with "/api".

In ASP.NET Core there is a chain of middleware components in the request processing pipeline. All requests and responses flow through this pipeline. When a new request arrives, these middleware components can either process the request or pass the request to the next component in the pipeline. For more complex request processing, we can use the Map and MapWhen methods to branch the pipeline and UseWhen to execute middleware conditionally

----------------------------------
Need of Middleware?

Helps to execute preprocessing logic in mvc before the controller is executed
							V(View)
user ---> C(controller)
							M(Model)
flow: user makes request to the controller then the controller takes data from the model and then sends the complete to the view where binding takes place and then the view(html) is sent back to the user

now if we want to insert pre processing logic thats where middleware comes in the picture

							V(View)
user Mw(middleware)--> C(controller)
							M(Model)
in the request pipeline before the request hits the controller
----------------------------------
How to implement Middleware?

goto project> rightclick> Add new item> search middleware template>add the middleware class

This middleware has a method called Invoke():
here we can write the pre processing logic

To put this middleware into pipeline:
IN THE Configure() method in the startup.cs:
app.UseMiddleware<CustomAuthentication>();
----------------------------------
Difference between Webforms(2003), mvc5(2009), mvc core(2017)?

									Web forms  		 MVC5  		  MVC Core
cross platform| 					 No        		 No    		     Yes
performance|worst(view state and page life cycle)   Less than Core   Best of all
Simplification| 					 Complicated   medium   		simplified
Cloud ready|   						 no    			not complete    yes
Html control| 					very less  			good razor	 view  good
Configuration| 					 web.config 	 web.config  	Appsetting.json
DI|  							 third paty  	third party  	built in
Self hosting| 						no   			no  		 yes(kestrel)
static content|						 No  		no such folder  	Wwwroot
Nuget managed| 					  not fully 	not fully 		completely
drag and drop| 					full marks  	need to code 	need to code
Development|  					 only win  		 only win  		all


PERFORMANCE best of core because: no page life cycle view state DLL or components miniature : 10kb broken down into 1kb pieces and memory footprint is less
----------------------------------
MVC architecture:

Model
View
Controllers

Model: has the business logic, domain classs, customer class, supplier class, accounts
Views: html files(cshtml), css
Controller: connects the 2 and binds the two
----------------------------------
Why do we have wwwroot folder

we can store static content in this folder like htmls,css,js files
----------------------------------
Importance of appsettings.json?

store configuration data, con string version, json format name:value (previously web.config which was xml)
----------------------------------
How to read configurations from appsetting.json (GET csv)

IConfiguration configuration
ctr(conf)..set

1. _configuration.GetSection("MySettings").GetSection("DbConnection").Value;
2. _configuration.GetConnectionString("myDb1"); :: "ConnectionStrings": {"DefaultConnection": "Server=(...
3._configuration.GetValue<string>("Modules:Logging:logDb");

{
 "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\MSSQLLocalDB;Database=_CHANGE_ME;Trusted_Connection=True;MultipleActiveResultSets=true",
    "MyConn": "Data Source=.\\SQL2017;Initial Catalog=AjaxSamples;Integrated Security=true"
 }
}
==========
2.{
  "ConnectionStrings": {
    "myDb1": "Server=myServer;Database=myDb1;Trusted_Connection=True;",
    "myDb2": "Server=myServer;Database=myDb2;Trusted_Connection=True;"
  }
}

string myDb1ConnectionString = _configuration.GetConnectionString("myDb1");
================
3.
{
  "Modules": {
    "Logging": {
      "logDb": "Server=myServer;Database=myDb1;Trusted_Connection=True;",
    },
    "Tenants": {
      "tenantsDb": "Server=myServer;Database=myDb1;Trusted_Connection=True;",
    }
  } 
}
In this scenario we do not use the GetConnectionString method in the Microsoft.Extensions.Configuration namespace. Instead we use the GetValue method and use colon ":" to represent the hierarchy.

string logDbConnectionString = _configuration.GetValue<string>("Modules:Logging:logDb"); // read logDb connection string example
================
in order to read the keyvalue pair we need:
IConfiguration Interface
using Microsoft.Extensions.Configurations;

we need to provide this IConfiguration in constructor
public CustomerController:Controller{
public CustomerController(CustomerDbContext _db, IConfiguration configuration){
string connectionString=configuration["ConnString"];
}
}

{IF key in a key: then configuration["Environment:Production"]
or

if 
public UserController(IConfiguration iConfig)  
{  
   configuration = iConfig;  
} 
then:

string dbConn = configuration.GetSection("MySettings").GetSection("DbConnection").Value;
or
string dbConn2 = configuration.GetValue<string>("MySettings:DbConnection"); 
}

NOTE:
in web forms:
// Add a using directive at the top of your code file    
using System.Configuration;

// Within the code body set your variable    
string cs = ConfigurationManager.ConnectionStrings["connectionStringName"].ConnectionString;
----------------------------------
LOGGING/ logger:

Logger is available as DI (dependency injection) to the every controller by default. So we get an ILogger object in the constructor of the controller class.
public class HomeController : Controller  
{  
    private readonly ILogger _logger;  
    public HomeController(ILogger<HomeController> logger)   //needs not be the controllername, could be any name
    {  
        _logger = logger;
		_logger.log(LogLevel.Information,"Hello from controller");		
		//or
		_logger.LogInformation("Index Method Called!!!");  
		_logger.LogWarning("Index Method Called!!!");  
		
		try{
			throw new Exception("new exception");
		}
		catch(Exception e){
			_logger.LogError(e, "Error in creating object!!!");  
		}
    }  
}  
After this, call logging methods on the logger object that get in DI container.
public IActionResult Index()  
{  
    return View();  
}

The above methods (such as LogInformation etc.) are extension methods of log method. They internally pass the log level. We can also call the log method instead of these extension methods. The syntax of this method is relatively complicated. Log level has following possible values.
(CDEITWL) ENum:
1.Trace (LogTrace)
2.Debug (LogDebug)
3.Information (LogInformation)----- default this onward is logged
4.Warning (LogWarning)
5.Error (LogError)
6.Critical (LogCritical)
7.NONE Logfiltering

builder.Logging.ClearProviders(); //to clear default 4 logging used by .net core
builder.Logging.AddConsole(); //to add logging

NOTE: in .net previous versions:
public static IHostBuilder CreateHostBuilder(string[] args)=>
		Host.CreateDefaultBuilder(args)
			.ConfigureWebHostDefaults(webBuilder=>
			{
				webBuilder.UseStartup<Startup>();
			})
			.ConfigureLogging(builder=>
			{
				builder.ClearProviders(); //to clear default 4 logging used by .net core
				builder.AddConsole(); //to add logging
			})

EACH Log can have an associated event ID:
to group logging messages;

_logger.LogInformation(1001,"Event id and Index Method Called {count}!!!",5);  

Seq is a logger!
localhost:5341 or Browse Seq
NUGET Seq extension logging

now:
.ConfigureLogging(builder=>
			{
				builder.ClearProviders(); //to clear default 4 logging used by .net core
				builder.AddConsole(); //to add logging
				builder.AddSeq(); //to add SEQ logging provided by the NUGER package we installed DEFAULT PARAMETER: localhost:5341 which we can change
			})
			
USING APPROPRIATE LOG LEVEL is necessary
for this we use logging config which is specified outside of file! Logging means storage so directly proportional to money!
by default: INFORMATION! or greater than information!

appsettings.json:
{
	"Logging":{
		"LogLevel":{
			"Default":"Information",
			"Microsoft":"Warning",
			"Micosoft.Hosting.Lifetime":"Information"
		}
	},
	"AllowedHosts":"*"
}

appsettings.json << appsettings.Development.json is priority

{
	"Logging":{
		"LogLevel":{
			"Default":"Trace",
			"Microsoft":"Warning",
			"Micosoft.Hosting.Lifetime":"Information",
			"Logging.Controllers.WeatherForecastController":"Error" //only errors will be logged
		},
		"Seq":{
			"LogLevel":{
				"Default":"Information",
				"Microsoft":"Warning",
				"Micosoft.Hosting.Lifetime":"Information"
			}
		}
	}
}

LOGGING SCOPE:
Group a set of logical operations:
add common attributes or properties in that scope!:

using(_logger.BeginScope(new Dictionary<string,object>{{"personId", 5}}))
	{
		_logger.LogInformation("Hello");
		_logger.LogInformation("World");
	}
transaction or httpcontext!
DI in Configure(ILogger logger){}
not di in ConfigureServices as it sets the service and also not in the startup constructor. as before completion of DI container setup

BUILT IN:
Console, Debug, EventSource, EventLog, AzureAppServiceFile & AzureAppServicesBlob, ApplicationsInsights
3rd party: elmah, serilog, Log4net

builder.Logging.AddLog4Net();
create file with name: log4net.config:

﻿<?xml version="1.0" encoding="utf-8" ?>
<log4net>
	<appender name="DebugAppender" type="log4net.Appender.DebugAppender" >
		<layout type="log4net.Layout.PatternLayout">
			<conversionPattern value="%date [%thread] %-5level %logger - %message%newline" />
		</layout>
	</appender>
	<appender name="ConsoleAppender" type="log4net.Appender.ConsoleAppender">
		<layout type="log4net.Layout.PatternLayout">
			<conversionPattern value="%date %-5level: %message%newline" />
		</layout>
	</appender>
	<appender name="RollingFile" type="log4net.Appender.RollingFileAppender">
		<file value="C:\WebAPITutorial\CollegeApp\CollegeApp\Logs\log.txt" />
		<rollingStyle value="Composite"/>
		<maximumFileSize value="1KB" />
		<maxSizeRollBackups value="5" />
		<layout type="log4net.Layout.PatternLayout">
			<conversionPattern value="%date %5level %logger.%method [%line] - MESSAGE: %message%newline %exception" />
		</layout>
	</appender>
	<root>
		<level value="ALL"/>
		<appender-ref ref="DebugAppender" />
		<appender-ref ref="ConsoleAppender" />
		<appender-ref ref="RollingFile" />
	</root>
</log4net>
----------------------------------
Explain Dependency Injection:

Dependency injection is a (programming)practice of providing the dependent objects from outside rather than that class creating using the NEW keyword and this is done via a constructor or via the property or via method.
Dependency injection is basically providing the objects that an object needs (its dependencies) instead of having it construct them itself. It's a very useful technique for testing, since it allows dependencies to be mocked or stubbed out.
For Decoupling and Higher level not being dependent on lower level

Dependencies can be injected into objects by many means (such as constructor injection or setter injection)

TYPES:
Method(interface), 2. Property(setter), 3. Constructor:
There are three types of DI: CONSTRUCTION Injection, SETTER Injection, INTERFACE based Injection. The Construction Injection type of DI accepts their dependency at the constructor level which means that when creating an object of the class, their dependency passes through the constructor of the class. It provides a strong dependency contract between objects. The Setter Injection is also known as property injection. In this type of dependency injection, dependency passes through public property instead of the constructor. It allows us to pass the dependencies when required. It does not provide a strong dependency contract between objects. The interface-based dependency injection can be achieved by creating the common interface and other classes are implements this interface to inject the dependency. In this type of DI, we can use either constructor injection or setter injection.
----------------------------------
Need of Dependency Injection:

for example:
if we have:
CustomerDbContext custDbContext=new CustomerDbContext();
if we need to change it then the change needs to be done in all controllers
This creates a tightly coupled system
HENCE
By delegating object creation outside the caller we have better decoupled system. Change at one place and the changes are reflected across the application seamlessly

Change in one place i.e. program.cs, we can get the implementation change everywhere
services.AddScoped<CustomerDbContext, CustomerDbContextnewVersion>()
----------------------------------
HOW DO WE IMPLEMENT DEPENDENCY INJECTION?

To implement DI we need to provide the dependency object in Startup.cs file in ConfigureServices method

public void ConfigureServices(IserviceCollection services){
services.AddScoped<CustomerDbContext>();
services.AddTransient<>();
services.AddSingleton<>();
}
		services.AddDbContext<ApplicationDbContext>(
						options => options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection"))
						);
		The AddDbContext extension method registers DbContext types with a scoped lifetime by default

NOW IF ANYONE ANYWHERE ASKS FOR CustomerDbContext then he will get that instance injected

NOW IF WE HAVE A NEWER VERSION SO WE WILL DO:
services.AddScoped<CustomerDbContext, CustomerDbContextnewVersion>();

While some instructions suggest using services.AddScoped() to inject a DbContext as a dependency, services.AddDbContext() provides the same service lifetime (lifetime of a single request) and also gives you the ability to configure the service in the function call

ALL 3 TYPES OF DEPENDENCY INJECTION (MPC my p c )-> 1. Method(interface), 2. Property(setter), 3. Constructor:

1. private IProductDetails productDataUsingMethodDI = null;  
[InjectionMethod]public void AssignProductDetailsWithMethodDI(IProductDetails _productDetails)    
        {    
            productDataUsingMethodDI = _productDetails;    
            ProdDetails = productDataUsingMethodDI.GetProductDetails();    
        }    
2. public IProductDetails productData { get; set; }   ProductDetails ProdDetails = productData.GetProductDetails(); 
3. public IProductDetails ProductDetails;public ProductDataAccess(IProductDetails _productDetails){   this.ProductDetails = _productDetails;ProductDetails.GetProductDetails();}    
using DataAccess.Interfaces;    
using DataAccProductDetailsess;    
using System;    
using Unity;    
    
namespace DataAccess    
{    
    public class ProductDataAccess     
    {    
        #3. region Constructor DIProperties    
        /// <summary>    
        /// This property is for Constructor DI    
        /// </summary>    
        public IProductDetails ProductDetails;    
        #endregion    
  
        #2. region Dependant DISetter Properties    
        /// <summary>    
        /// This property is for Setter DI    
        /// </summary>    
        [Dependency]    
        public IProductDetails productData { get; set; }    
        #endregion    
  
        #1. region Method DI Properties    
        /// <summary>    
        /// This property is for Method DI    
        /// </summary>    
        private IProductDetails productDataUsingMethodDI = null;    
    
        /// 2. <summary>    
        /// Variable to assign product details    
        /// </summary>    
        public ProductDetails ProdDetails { get; set; }    
        #endregion    
  
        #region Constructor    
        ///3. <summary>    
        /// Injects dependancy using constructor    
        /// </summary>    
        /// <param name="_productDetails"></param>    
        public ProductDataAccess(IProductDetails _productDetails)    
        {    
            this.ProductDetails = _productDetails;    
            ProductDetails.GetProductDetails();    
        }    
        #endregion    
  
        #region Method Injection    
        /// <summary>    
        /// This method prints product details using Constructor DI    
        /// </summary>    
        public void PrintProductDetails()    
        {    
            ProductDetails ProdDetails = ProductDetails.GetProductDetails();    
            Console.WriteLine("***********************************Receipt From Construcor DI**************************************");    
            Console.WriteLine("                Product :"+ ProdDetails.ProductName);    
            Console.WriteLine("                Price   :" + ProdDetails.ProductPrice);    
            Console.WriteLine("                Quantity:" + ProdDetails.ProductQuantity);    
            Console.WriteLine("******************Thank you for shopping with Us !!!!!***********************");    
    
        }    
    
        /// <summary>    
        /// This method prints product details using Property DI    (DI SETTER)
        /// </summary>    
        public void PrintProductDetailsWithPropDI()    
        {    
            ProductDetails ProdDetails = productData.GetProductDetails();    
            Console.WriteLine("***********************************Receipt From Property/Setter DI***********************************");    
            Console.WriteLine("                Product :" + ProdDetails.ProductName);    
            Console.WriteLine("                Price   :" + ProdDetails.ProductPrice);    
            Console.WriteLine("                Quantity:" + ProdDetails.ProductQuantity);    
            Console.WriteLine("******************Thank you for shopping with Us !!!!!***********************");    
        }    
    
        /// 1. <summary>    
        /// This method injects product details using Method DI    
        /// </summary>    
        [InjectionMethod]    
        public void AssignProductDetailsWithMethodDI(IProductDetails _productDetails)    
        {    
            productDataUsingMethodDI = _productDetails;    
            ProdDetails = productDataUsingMethodDI.GetProductDetails();    
        }    
    
        /// <summary>    
        /// This method prints product details using Method DI    
        /// </summary>    
        public void PrintProductDetailsWithMethodDI()    
        {                 
            Console.WriteLine("***********************************Receipt From Methos DI***********************************");    
            Console.WriteLine("                Product :" + ProdDetails.ProductName);    
            Console.WriteLine("                Price   :" + ProdDetails.ProductPrice);    
            Console.WriteLine("                Quantity:" + ProdDetails.ProductQuantity);    
            Console.WriteLine("******************Thank you for shopping with Us !!!!!***********************");    
        }    
        #endregion    
    }    
}   

side note:::::
.AddDbContext also allows you to configure it at the same time. Configuration can't work with the abstract type, since you have to pass a IDbContextOptionsBuilder<T> into your DbContext, where T is your concrete implementation.

However, you can use both together if you want to inject the abstract class.

{{{{{{{{{{{{services.AddDbContext<AppDbContextMySql>( /* configure it */); //options => options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")
services.AddDbContext<AppDbContextSqlServer>( /* configure it */);
}}}}}}}}}}}}

{{{{{{{{{{{{{services.AddScoped<AppDbContextContract>(p => p.GetRequiredService<AppDbContextMySql>());  //MySQL
services.AddScoped<AppDbContextContract>(p => p.GetRequiredService<AppDbContextSqlServer>());           //SqlServer
Not using .AddDbContext you'd need to write

var dbOptionsA = new DbContextOptionsBuilder<AppDbContextMySql>();
dbOptionsA.UseMySql(...);
services.AddSingleton(dbOptionsA);
var dbOptionsB = new DbContextOptionsBuilder<AppDbContextSqlServer>();
dbOptionsB.UseSqlServer(...);
services.AddSingleton(dbOptionsB);
}}}}}}}}}}}}}}}}}

services.AddScoped<AppDbContextContract,AppDbContextMySql>();
services.AddScoped<AppDbContextContract,AppDbContextSqlServer>();
----------------------------------

DI in mvc5:
public static void RegisterComponents()  
{  
    var container = new UnityContainer();         
    container.RegisterType<IUserMasterRepository, UserMasterRepository>();  
    DependencyResolver.SetResolver(new UnityDependencyResolver(container));  
}  
Add UnityConfiguration in AppStart method of Global.asax
protected void Application_Start()  
{  
    AreaRegistration.RegisterAllAreas();
    FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
    RouteConfig.RegisterRoutes(RouteTable.Routes);
    BundleConfig.RegisterBundles(BundleTable.Bundles);
    UnityConfig.RegisterComponents();  
}  
-----------------------------------
SINGLETON: Same object for every controller and request.
SCOPED: Same within a request but different across different requests.
TRANSIENT: Always different. A new instance is created on every controller and every service (can be resource hungry).

In a nutshell:
ConfigureServices is used to configure Dependency Injection
public void ConfigureServices(IServiceCollection services)
{
    // register MVC services
    services.AddMvc();

    // register configuration
    services.Configure<AppConfiguration>(Configuration.GetSection("RestCalls")); 

    // register custom services
    services.AddScoped<IUserService, UserService>();
    ...
}
Configure is used to set up middlewares, routing rules, etc

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    // configure middlewares
    app.UseMiddleware<RequestResponseLoggingMiddleware>();
    app.UseMiddleware<ExceptionHandleMiddleware>();

    app.UseStaticFiles();

    // setup routing
    app.UseMvc(routes =>
    {
        routes.MapRoute(
            name: "Default",
            template: "{controller}/{action}/{id}",
            defaults: new { controller = "Home", action = "Index", id = 1 });

    });
}
//app.UseEndpoints(endpoints =>
        {
//endpoints.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}",
	//defaults: new { controller = "Blog", action = "Article" });

For earlier versions of ASP.NET Core like 2.0, 2.1 & 2.2. We used the app.UseMvc() method which is very much similar to app.UseEndpoints(). See it’s code below:
app.UseMvc(routes =>
{
   routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
}

For Dot Net 5.0 and ASP.NET Core 3.0
If you are using these versions then check the Configure() method of Startup.cs class where default route (‘default’ is just a name and can be anything) is added. Inside the UseEndpoints method, Endpoints for Controller’s action is provided. For this the MapControllerRoute() method is used to create a single route as shown below:	
	if:
	app.UseRouting();
	then:
	app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(
        name: "default",
        pattern: "{controller=Home}/{action=Index}/{id?}");
    });
	
in .net core 6+:
app.UseRouting();
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
	

	//default:
	/*
	app.UseMvc(routes =>
    {
        routes.MapRoute(
            name: "default",
            template: "{controller=Home}/{action=Index}/{id?}");
    });
	*/
	
	Endpoint routing’s two extension methods are:

UseRouting: It matches request to an endpoint.
UseEndpoints: It execute the matched endpoint


MapRazorPages()
This sets the endpoint routing for Razor Pages. Sample endpoint configuration as below:

app.UseEndpoints(endpoints =>
{
    endpoints.MapRazorPages();
});
MapGet()
Adds a route that only matches HTTP GET requests. The code given below will show the ‘Hello world’ message for the root page of the website in the browser:

app.UseEndpoints(endpoints =>
{
    endpoints.MapGet("/", context => context.Response.WriteAsync("Hello world"));
});



You can also enable Authorization on a single endpoint so that only ‘Admin’ roles are able to view the corresponding URL like this:

app.UseEndpoints(endpoints =>
{
    endpoints.MapGet("/secured", 
        context => context.Response.WriteAsync("Secured Page"))
        .RequireAuthorization(new AuthorizeAttribute() { Roles = "admin" });
});


The Routes are applied in the order in which they are defined in the Program class. The ASP.NET Core Routing tries to match the incoming URL against the first defined route and proceeds only to the next route only if there is no match. Therefore you must define the most specific routes first.

Let’s add the below shown 2 routes to the app’s Program.cs class:

app.MapControllerRoute(
    name: "old",
    pattern: "Shopping/Old",
    defaults: new { controller = "Home", action = "Index" });
 
app.MapControllerRoute(
    name: "shop",
    pattern: "Shopping/{action}",
    defaults: new { controller = "Home" });
	
++++++++++++++++++++++
Ways of doing DI in mvc core?
Explain SCOPED, TRANSIENT, SINGLETON?
++++++++++++++++++++++
services.AddScoped<>();
++++++++++++++++++++++
Instantiates once per request made to server::Scoped objects are the SAME WITHIN A REQUEST, but different across different requests.

ex:
public HomeController(Customer obj, Customer obj1){}

if user sends 1st request then INSTANCE1 created and the same will be there of obj and obj1
if user sends 2nd request then INSTANCE2 created and the same will be there of obj and obj1

Scoped lifetime services are created once per request within the scope. It is equivalent to a singleton in the current scope. For example, in MVC it creates one instance for each HTTP request, but it uses the same instance in the other calls within the same web request.
++++++++++++++++++++++
services.AddTransient<>();
++++++++++++++++++++++
Instantiates fresh instance i.e. new instances every singletime service is injected ::Transient objects are ALWAYS different; a new instance is provided to every controller and every service.

ex:
if user sends 1st request then INSTANCE1, INSTANCE2 created and the different will be there for obj and obj1
if user sends 2nd request then INSTANCE3,INSTANCE4 created and different will be there for obj and obj1

Transient lifetime services are created each time they are requested. This lifetime works best for lightweight, stateless services.
++++++++++++++++++++++
services.AddSingleton<>();
++++++++++++++++++++++
Instantiates once in an application life time, only one global instance is created::Singleton objects are the SAME FOR EVERY OBJECT AND EVERY REQUEST.

if user sends 1st request then INSTANCE created and the same will be there for obj and obj1
if user sends 2nd request then same INSTANCE used and the same will be there for obj and obj1
if another user and he sends request then he will also use the same instance

Singleton which creates a single instance throughout the application. It creates the instance for the first time and reuses the same object in the all calls.
----------------------------------
Service lifetime:

Service Lifetime
ASP.net core allows us to specify the lifetime for registered services. The service instance gets disposed of automatically based on a specified life-time. So we do not care about the cleaning these dependencies, it will take care of the ASP.net core framework. There are three types of life-times.

Singleton
ASP.net core will create and share a single instance of the service through the application life. The service can be added as a singleton using the AddSingleton method of IServiceCollection. ASP.net core creates a service instance at the time of registration and subsequence requests use this service instance. Here, we do not require implementing a singleton design pattern and single instance maintained by the ASP.net core itself.

public void ConfigureServices(IServiceCollection services)
{
 ….
 …
 services.AddSingleton<IHelloWorldService, HelloWorldService>();
 ….
 …
}
Transient
ASP.net core will create and share an instance of the service every time to the application when we ask for it. The service can be added as Transient using the AddTransient method of IServiceCollection. This lifetime can be used in stateless service. It is a way to add lightweight service.

In other words, the transient service will be created every time as soon as it will get the request for the creation.

public void ConfigureServices(IServiceCollection services)
{
 ….
 …
 services.AddTransient<IHelloWorldService, HelloWorldService>();
 ….
 …
}
Scoped
ASP.net core will create and share an instance of the service per request to the application. It means that a single instance of service is available per request. It will create a new instance in a new request. The service can be added as scoped using the AddScoped method of IServiceCollection. We need to take care while, the service is registered via Scoped in middleware and inject the service in the Invoke or InvokeAsync methods. If we inject dependency via the constructor, it behaves like a singleton object.

public void ConfigureServices(IServiceCollection services)
{
 ….
 …
 services.AddScoped<IHelloWorldService, HelloWorldService>();
 ….
 …
}



DI in views:

Dependency injection into Views
ASP.net core can also able to inject the dependency to View. This is very useful to inject service related views such as localization. This method will bypass the controller call and fetch data directly from the service. We can inject the service dependency into the view using the @inject directive. The syntax is as follows to use this directive. Here we need to pass the service type that needs to inject and the service instance name that is used to access the service method.

There are multiple ways to define or consume the data to the View layer of the MVC and the ways are there such as ViewModel, ViewBag, ViewData, etc. With respect to ASP.NET Core, One of the suitable ways to supply the data is by creating a custom service that is used via the DI (dependency injection). However, it is not a best practice and depends on certain parameters according to the component configurations.

@inject <type> <instance name>
Example
In the following example, I have used the same service that was created in the preceding section and injected it into the view using the:::: @inject :::::directive, and using the service instance, we can call the service method into the view.

@{
 ViewData["Title"] = "DIToView";
}
@inject DepedencyInjectionExample.Service.IHelloWorldService helloWorldService

<h4>DI To View</h4>

<h5>
 @helloWorldService.SaysHello() Reader!!!
</h5>
--------------------------------
TryAddSingleton vs AddSingleton?:

TryAdd (called by TryAddSingleton) adds the specified param "descriptor" to the "collection" if the service type hasn't been already registered

AddSingleton always appends the registration to the collection, while TryAddSingleton only does this when there exists no registration for the given service type.

When multiple registrations exist for the same service type, but a single instance is requested, .NET Core will always return the last one registered. This means that the behavior of AddSingleton is to effectively replace instances for non-collection resolution, for instance:

services.AddSingleton<IX, A>();
services.AddSingleton<IX, B>(); // ‘replaces’ A
IX x = container.GetService<IX>(); // resolves B

For collection resolution however, AddSingleton behaves as a collection ‘append’ of already existing registrations for that service type. For instance:

services.AddSingleton<IX, A>();
services.AddSingleton<IX, B>();
IEnumerable<IX> xs = container.GetServices<IX>(); // resolves A *and* B

TryAddSingleton is especially useful for framework and third-party library code that wishes to register its own components to the container. It allows an application developer to override the framework or library’s default registration, even if the application developer registered that component before the framework or third-party AddXXX extension method is called

You can register a service using TryAddSingleton(), TryAddScoped(), or TryAddTransient() in an Asp.Net Core Web Api Application
----------------------------------

ActionResult vs ViewResult:
ActionResult is an abstract class that can have several subtypes(VPERRrJJsCFRaHnf).

ActionResult Subtypes with helper method:
ViewResult - Renders a specifed view to the response stream:: return View()

PartialViewResult - Renders a specifed partial view to the response stream:: return PartialView("_PartialView")

EmptyResult - An empty response is returned.:: return None()

RedirectResult - Performs an HTTP redirection to a specifed URL:: return Redirect("Home/Contact")

RedirectToRouteResult - Performs an HTTP redirection to a URL that is determined by the routing engine, based on given route data:: return RedirectToAction(),RedirectToRoute(),RedirectToActionPermanent(),RedirectToRoutePermanent().

JsonResult - Serializes a given ViewData object to JSON format:: return Json(persons, JsonRequestBehavior.AllowGet)

JavaScriptResult - Returns a piece of JavaScript code that can be executed on the client:: return Javascript()

ContentResult - Writes content to the response stream without requiring a view, HTML JS any other format:: return Content("<script>alert('Welcome')</script>")
ViewBag.Message="hello";return View();

{{{{{{
FileContentResult - Returns a file to the client:: return File()
FileStreamResult - Returns a file to the client, which is provided by a Stream:: return File()
FilePathResult - Returns a file to the client:: return File("Web.Config","text")
}}}}}}
RedirectToAction - Redirects to result to specified controller and action:: return RedirectToAction("Login","Account")
HttpNotFoundResult - returns an object to indicate req resource cannot be found.:: return HttpNotFound()
----------------------------------
ActionResult vs IActionResult:

IActionResult is an interface and ActionResult is an implementation of that interface.

ActionResults is an abstract class and action results like ViewResult, PartialViewResult, JsonResult, etc., derive from ActionResult.

Let's say you want to create an action result not catered to by MVC, say an XML result. 
IActionResult is an interface, we can create a custom response as a return, when you use ActionResult you can return only predefined ones for returning a View or a resource. With IActionResult we can return a response, or error as well. On the other hand, ActionResult is an abstract class, and you would need to make a custom class that inherits.

----------------------------------
MVC vs webapi:

Difference between MVC & Web APIs: 

Model View Controller
Web API
MVC is used for developing Web applications that reply to both data and views
Web API is used for generating HTTP services that reply only as data.

When receiving the request, MVC performs tracing based on the action name.
When receiving the request, Web API performs tracing based on HTTP requests.

 By using JSONResult, MVC returns the data in the JSON format
Depending on the accepted header of the request, The Web API returns data in JSON, XML, and different formats

“System.Web.MVC” assembly has all defined features of MVC.
“System.Web.Http” assembly has all features of MVC but does not have routing, and model binding which are exclusive to Web API.

MVC does not either support content negotiation or self-hosting.
Web API supports content negotiation, self-hosting

MVC controller is extremely heavy and we can see the number of interfaces the code uses.
Web API has a lighter controller and it can distinguish requests by their passed parameters

MVC controller cant support API views as it is tightly coupled with the views.
Web API can be hosted anywhere without worrying about the views.

Popular MVC Frameworks are Ruby on Rails, Django, CherryPy, Spring MVC, Catalyst, etc.	Popular API Examples are Google Maps API, YouTube API, Twitter API, etc.
----------------------------------
Actionresult Asp.netcore api:

ObjectResult primary role is content negotiation. It has some variation of a method called SelectFormatter on its ObjectResultExecutor. You can return an object with it, and it formats the response based on what the user requested in the Accept header. If the header didn’t exist, it returns the default format configured for the app. It’s important to note that if the request is issued through a browser, the Accept header will be ignored, unless we set the RespectBrowserAcceptHeader to true when we configure the MVC options in Startup.cs. Also, it doesn’t set the status code, which causes the status code to be null. ObjectResult is the super type of following:

AcceptedResult
AcceptedAtActionResult
AcceptedAtRouteResult
BadRequestObjectResult
CreatedResult
CreatedAtActionResult
CreatedAtRouteResult
NotFoundObjectResult
OkObjectResult
AcceptedResult

An AcceptedResult that returns an Accepted (202) response with a Location header. It indicates that the request is successfully accepted for processing, but it might or might not acted upon. In this case, we should redirect the user to a location that provides some kind of monitor on the current state of the process. For this purpose, we pass a URI.

public AcceptedResult AcceptedActionResult()
{
    return Accepted(new Uri("/Home/Index", UriKind.Relative), new { FirstName = "Farhan",LastName="Ahmed" });
}
C#
AcceptedAtActionResult

An AcceptedAtActionResult action result returns an accepted 202 response with a location header.

public AcceptedAtActionResult AcceptedAtActionActionResult()
{
   return AcceptedAtAction("IndexWithId", "Home", new { Id = 2, area = "" }, new { FirstName = "Farhan",LastName="Ahmed" });
}
C#
AcceptedAtRouteResult

An AcceptedAtRouteResult returns an Accepted (202) response with a Location header. It's the same as AcceptedResult, with the only difference being that it takes a route name and route value instead of URI.

public AcceptedAtRouteResult AcceptedAtRouteActionResult()
{
   return AcceptedAtRoute("default", new { Id = 2, area = "" }, new { FirstName = "Farhan", LastName = "Ahmed" });
}
C#
BadRequestResult

An ObjectResult, when executed. will produce a Bad Request (400) response. It indicates a bad request by user. It does not take any argument.

public BadRequestResult BadRequestActionResult()
{
    return BadRequest();
}
C#
BadRequestObjectResult

This is similar to BadRequestResult, with the difference that it can pass an object or a ModelStateDictionary containing the details regarding the error.

public BadRequestObjectResult BadRequestObjectActionResult()
{
    var modelState = new ModelStateDictionary();
    modelState.AddModelError("Name", "Name is required.");
    return BadRequest(modelState);
}
C#
CreatedResult

CreatedResult returns a Created (201) response with a Location header. This indicates the request has been fulfilled and has resulted in one or more new resources being created.

public CreatedResult CreatedActionResult()
{
     return Created(new Uri("/Home/Index", UriKind.Relative), new { FirstName = "Farhan", LastName = "Ahmed" });
}
C#
CreatedAtActionResult

CreatedAtActionResult that returns a Created (201) response with a Location header.

public CreatedAtActionResult CreatedAtActionActionResult()
{
    return CreatedAtAction("IndexWithId", "Home", new { id = 2, area = "" }, new { FirstName = "Farhan", LastName = "Ahmed" });
}
C#
CreatedAtRouteResult

CreatedAtRouteResult that returns a Created (201) response with a Location header.

public CreatedAtRouteResult CreatedAtRouteActionResult()
{
    return CreatedAtRoute("default", new { Id = 2, area = "" }, new { FirstName = "Farhan", LastName = "Ahmed" });
}
C#
NotFoundResult

This represents a StatusCodeResult that when executed, will produce a Not Found (404) response.

public NotFoundResult NotFoundActionResult()
{
    return NotFound();
}
C#
NotFoundObjectResult

This is similar to NotFoundResult, with the difference being that you can pass an object with the 404 response.

public NotFoundObjectResult NotFoundObjectActionResult()
{
    return NotFound(new { Id = 1, error = "There was no customer with an id of 1." });
}
C#
OkResult

This is a StatusCodeResult. When executed, it will produce an empty Status200OK response.

public OkResult OkEmptyWithoutObject()
{
    return Ok();
}
C#
OkObjectResult

An ObjectResult, when executed, performs content negotiation, formats the entity body, and will produce a Status200OK response if negotiation and formatting succeed.

public OkObjectResult OkObjectResult()
{
    return new OkObjectResult(new { Message="Hello World !"});
}
C#
NoContentResult

The action result returns 204 status code. It’s different from EmptyResult in that EmptyResult returns an empty 200 status code, but NoContentResult returns 204. Use EmptyResult in normal controllers and NoContentResult in API controllers.

public NoContentResult NoContentActionResult()
{
    return NoContent();
}
C#
StatusCodeResult

StatusCodeResult accepts a status code number and sets that status code for the current request. One thing to point is that you can return an ObjectResult with and status code and object. There is a method on ControllerBase called StatusCode (404, new {Name = "Farhan Ahmed”}), which can take a status code and an object and return an ObjectResult.

public StatusCodeResult StatusCodeActionResult()
{
    return StatusCode(404);
}

----------------------------------
WEB api tuning:

1.PARALLEFOREACH:
A simple foreach loop is a single threaded loop which processes the data sequentially, one by one, to give the result set.
So, in this case, it is recommended to use parallel foreach loop while getting the data from the server. As the parallel foreach loop works in multi-threaded environment, the execution will be faster than foreach loop.
Parallel.ForEach(li,x=>
{
	c.wl(x.id,...)
}
)
The loop will execute at once and give the result. In case of Foreach Loop, it gives results one by one. Suppose we have 1000 records in the result set, the loop will execute one by one 1000 times to give the result.
Note- Please don't use the Parallel foreach loop while you have very little amount of records to fetch.

2. ASYNCHRONOUS PROGRAMMING TO HANDLE THE CONCURRENT HTTP


----------------------------------
Fluent Validation:

Different class doing validation and not in the model. Powerful:


MODEL:
public class User
{
	public string? Name { get; set; }
	public int Age { get; set; }

	public DateTime Date { get; set; }

	public string? Email { get; set; }

	public string? PhoneNumber { get; set; }

	public string? Address { get; set; }

	public Membership[]? Membership { get; set; }

}

public record Membership(string Name);

+++
using FluentValidation;

namespace APIValidation.Demo;
public class UserValidator : AbstractValidator<User>

{
	public UserValidator()
	{
		RuleFor(u => u.Name).NotNull().NotEmpty().WithMessage("errorMsg") ;
		RuleFor(u => u.Email).EmailAddress().DependantRule(RuleFor(u=>u.st)...);
		RuleFor(u => u.Address).NotNull().MaximumLength(10) ;
		RuleFor(u => u.Address)
			.Must(a => a?.ToLower().Contains("street") == true); or MustAsync(func) func(id,cancellationToken)
	}
}

in program.cs:
using FluentValidation.AspNetCore;
using System.Reflection;

var builder = WebApplication.CreateBuilder(args) ;

builder.Services.AddControllers()
	.AddFluentValidation(c =>
		c.RegisterValidatorsFromAssembly(Assembly.(Assembly.GetExecutingAssembly()));
...
var app=builder.Build()
...



modify for having more validation in same:

public class UserValidator : AbstractValidator<User>
{
	public UserValidator()
	{
		RuleFor(u => u.Name).NotNull().NotEmpty() ;
		RuleFor(u => u.Email).EmailAddress();
		RuleFor(u => u.Address).NotNull().MaximumLength(10) ;
		RuleFor(u => u.Address)
			.Must(a => a?.ToLower().Contains("street") == true);
			.WithMessage("Address must contain street");
		RuleForEach(u => u.Memberships)
			.SetValidator(new MembershipValidator());
			//if not above then:
			// .ChildRules(x=>x.Name).NotEmpty().NotNull();
	}
}

public class MembershipValidator : AbstractValidator<Membership>
public MembershipValidator()
{
	RuleFor(x=>x.Name).NotEmpty().NotNull();
}


ALSO if much code then break in classes and then: {simplevalidation,complexvalidation}

public class UserValidator: AbstractValidator<User>
{
	public UserValidator()
	{
		Include(new UserSimpleValidator());
		Include(new UserComplexValidator());
	}
}

----------------------------------
Custom Validation Attribute Annotation:

public sealed class EmailAttribute : ValidationAttribute
{

    public override bool IsValid(object value)
    {
        return new RegularExpressionAttribute(@"^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,6}$").IsValid(Convert.ToString(value).Trim());
    }
}

public class DataClass
{
    [Email]
    public string EmailAddress { get; set; }

    [MyRequiredAttribute(ErrorMessage = "Jignesh Test")]
    public string Password { get; set; }
}

Conclusion

System.ComponentModel.DataAnnotations allow us to create new validation attributes to write custom logic or code for validation. In MVC, creation of new attributes that are automatically picked up by the validation process of the DefaultModelBinder is easy.
...
public sealed class MyRequiredAttribute : ValidationAttribute
{
    public override bool IsValid(object value)
    {
        var required = new RequiredAttribute();
        return required.IsValid(Convert.ToString(value).Trim());
    }
}

Custom Attribute
You can implement a custom attribute if built-in ASP.NET Core validation attributes do not meet your requirements.

The steps below describe how to create the VerifyAge attribute and apply it to the DateBox control. The attribute should check if a person is over the specified age, for example, the age of 21.

Create the VerifyAgeAttribute class that implements the validation logic. Duplicate the logic on the client and on the server. To do this, declare the class that is inherited from the ValidationAttribute﻿ class and implements the IClientModelValidator﻿ interface.

Implement the following methods:

IsValid

Validates data on the server to ensure invalid values are not sent when JavaScript is switched off on the client.

AddValidation

Adds the following attributes to the attribute dictionary. DevExtreme client-side validation engine uses these attributes.

data-val-custom-verifyage - Accepts a formatted validation message.

data-val-custom-verifyage-validationcallback - Specifies a JavaScript function that implements the validation logic.

NOTE

The attribute names should be in the following format: data-val-custom-yourattribute and data-val-custom-yourattribute-validationcallback .

FormatErrorMessage

Overrides the default FormatErrorMessage﻿ method.

Custom Attribute Class
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using Microsoft.AspNetCore.Mvc.ModelBinding.Validation;

namespace DevExtreme.NETCore.Demos.ViewModels {
    public class VerifyAgeAttribute : ValidationAttribute, IClientModelValidator {
        public VerifyAgeAttribute(int age) {
            Age = age;
        }
        public int Age { get; private set; }
        protected override ValidationResult IsValid(object value, ValidationContext validationContext) {
            if((DateTime?)value <= DateTime.Now.AddYears(-Age)) {
                return ValidationResult.Success;
            }
            return new ValidationResult(FormatErrorMessage(validationContext.DisplayName));
        }
        void IClientModelValidator.AddValidation(ClientModelValidationContext context) {
            context.Attributes.Add("data-val-custom-verifyage", FormatErrorMessage(context.ModelMetadata.GetDisplayName()));
            context.Attributes.Add(
                "data-val-custom-verifyage-validationcallback",
                $@"function(options) {{
                    var now = new Date();
                    return options.value && options.value <= now.setFullYear(now.getFullYear() - {Age});
                }}");
        }
        public override string FormatErrorMessage(string name) {
            return string.Format(ErrorMessageString, name, Age);
        }
    }
}

Attach the VerifyAge attribute to a model property and specify an age.

Model
using System.ComponentModel.DataAnnotations;

namespace ApplicationName.Models {
    public class Person {
        // ...
        [VerifyAge(21, ErrorMessage = "You must be at least {1} years old")]
        public DateTime? BirthDate { get; set; }
    }
}

Bind the DateBox control to the BirthDate model property. Refer to Validate an Editor for more information.

Razor C#
@model ApplicationName.Models.Person

// ...

@(Html.DevExtreme().DateBoxFor(model => model.BirthDate))
----------------------------------
Valiadtion Attributes:

DevExtreme-based controls support several built-in ASP.NET Core attributes﻿ that reside in the System.ComponentModel.DataAnnotations﻿ namespace and other validation attributes:

[Attribute]			Description	Remarks
Compare				Validates that two properties in a model match.	Built-in
Range				Validates that a property value falls within a specified range.	Built-in
RegularExpression	Validates that a property value matches a specified regular expression.	Built-in
Remote				Performs a remote validation: you call an action method on the server to validate inputs on the client.	Built-in
Required			Validates that an editor’s value is not null.	Built-in
StringLength		Validates that a string property value does not exceed a specified length limit.	Built-in
DevExtremeRequired	Validates that a boolean property value is true.	DevExtreme-specific
A custom attribute	You can create a custom validation attribute.	

ex:[Compare("Password", ErrorMessage = "Password and confirm password does not match")]    
        public string ConfirmPassword { get; set; }   

using System.ComponentModel.DataAnnotations;

namespace ApplicationName.Models {
    public class Person {
        [Required(ErrorMessage = "First name is required")]
        [RegularExpression(@"^[a-zA-Z\s]+$", ErrorMessage = "Please, use letters in the first name. Digits are not allowed.")]
        [StringLength(int.MaxValue, MinimumLength = 2, ErrorMessage = "First name must have at least 2 characters")]
        public string FirstName { get; set; }
		
		//[Range(typeof(DateTime), "1/1/1901", "1/1/2016")]
    }
}

+++++++++++++++++++
Remote Attribute
The Remote attribute﻿ allows you to perform remote data validation. You can CALL AN ACTION method on the server to validate inputs on the client.

Controller
[HttpPost]
public IActionResult CheckEmailAddress(string email) {
    if(!_userRepository.VerifyEmail(email)) {
        return Json($"Email {email} is already registered.");
    }

    return Json(true);
}

using System.ComponentModel.DataAnnotations;

[Remote("CheckEmailAddress", "Validation")]
public string Email { get; set; }


@model ApplicationName.Models.Person

// ...

@Html.DevExtreme().TextBoxFor(model => model.Email)

++++++++++++++++++
The DevExtremeRequired attribute resides in the DevExtreme.AspNet.Mvc namespace and allows you to verify if a boolean value is true

Razor C#
@using(Html.BeginForm("EditPerson", "Home", FormMethod.Post, new { id = "editPerson" })) {
    @(Html.DevExtreme().Form<Person>()
        .Items(items => {
            // ...
            items.AddSimpleFor(model => model.Accepted)
                .Label(label => label.Visible(false))
                .Editor(editor => editor.CheckBox().Text("I agree to the Terms and Conditions"));
        })
    )
}

Model
using DevExtreme.AspNet.Mvc;
using System.ComponentModel.DataAnnotations;

namespace ApplicationName.Models {
    public class Person {
        // ...
        [DevExtremeRequired(ErrorMessage = "You must agree to the Terms and Conditions")]
        public bool Accepted { get; set; }
    }
} 

+++++++++++++++++++++++++++++++
----------------------------------
Validations in .net mvc core:
The term _ValidationScriptsPartial is commonly used in ASP.NET MVC web applications. It refers to a partial view that contains the validation scripts required for client-side validation of form fields.

When you use client-side validation in an ASP.NET MVC web application, the validation logic is executed on the client side (in the browser) using JavaScript. To enable client-side validation, you need to include the necessary validation scripts in your web page. These scripts are provided by the ASP.NET MVC framework and are loaded automatically when you use the Html.ValidationMessageFor or Html.ValidationSummary helper methods in your views.

Default client side validation scripts already provided in “Pages/Shared/_ValidationScriptsPartial.cshtml”. Simply include validation partial into “Trips.cshtml” file directly after closing the form tag:

@section Scripts{ 
    <partial name="_ValidationScriptsPartial" />
}

[Required(ErrorMessage = "Please enter date of birth")]    
[Display(Name = "Date of Birth")]    
[DataType(DataType.Date)]    
public DateTime DateofBirth { get; set; }

in start:
<div asp-validation-summary="ModelOnly" class="text-danger"></div>  
	
<input asp-for="Password" class="form-control" />  
<span asp-validation-for="Password" class="text-danger">

above code has studendataaccesslayer:
now 
StudentDataAccessLayer studentDataAccessLayer = null;  
public StudentController()  
 {  
   studentDataAccessLayer = new StudentDataAccessLayer();  
 }  
 
 [HttpPost]  
[ValidateAntiForgeryToken]  
public ActionResult Create(Student student)  
{  
    try  
    {  
        // TODO: Add insert logic here  
        studentDataAccessLayer.AddStudent(student);  
  
        return RedirectToAction(nameof(Index));  
    }  
    catch(Exception ex)  
    {  
        return View();  
    }  
}

----------------------------------
Need of _ValidationScriptsPartial:
@section Scripts {
    <partial name="_ValidationScriptsPartial" />
}

We discussed layout sections in Part 29 of ASP.NET Core tutorial.

How client side validation works in asp.net core

Consider the following Name input element. We have used asp-for tag helper to bind to Name property of the Employee class.

<input asp-for="Employee.Name">

We have used [Required] attribute, on the Name property of the Employee class. This attribute makes the Name input field a required field. The following is the generated HTML.

<input id="Employee_Name" name="Employee.Name" type="text"
        data-val="true" data-val-required="Name is required" />

Notice we have several special data-* attributes. These attributes allow us to add extra information to an HTML element. data-val="true" enables client-side validation.  data-val-required attribute specifies the required validation error message to display if the validation fails. These data-* attributes carry all the information required to perform client-side validation. It is the unobtrusive library (i.e jquery.validate.unobtrusive.js) that reads these data-* attributes and performs client side validation

----------------------------------
Routing in mvc core:

Routing is the process through which the application matches an incoming URL path and executes the corresponding action methods. ASP.NET Core MVC uses a routing middleware to match the URLs of incoming requests and map them to specific action methods.

We can define the routes either in the startup code or as attributes. They describe how we can match the URL paths with the action methods. We can also use routes to generate URLs for links that are sent out in responses.

There are two types of routing for action methods:

1.Conventional Routing
2.Attribute Routing

conventional routing: //app.MapControllerRoute(name,pattrn,defaults: after .net 6;  and app.UseEndpoints(endpoints=>{endpoints.MapControllerRoute( for 4 & 5; and app.UseMvc(routes=>{routes.MapRoute(

app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(
        name: "blog",
        pattern: "blog/{*article}",
        defaults: new { controller = "Blog", action = "Article" 
		});
		
    endpoints.MapControllerRoute(
        name: "default",
        pattern: "{controller=Books}/{action=Details}/{id?}"
		);
});

defaults: new { controller = "Blog", action = "Article", id=UrlParameter.Optional }

.net 6.0+::------------
app.UseRouting();
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
----------------------

attribute routing:
[Route("")]
[Route("Home")]
[Route("Home/Index")]
    public IActionResult Index()
    {
        return View();
    }
[Route("Home/Details/{id:int}")]
    public IActionResult Details(int id)
    {
        ViewBag.Id = id;
        return View();
    }


We can also use Http[Verb] attributes for Attribute Routing:

[HttpGet("/books")]
public IActionResult ListBooks()
{
   // ...
}
[HttpPost("/books")] //[ActionName("Create")] //if same name of two actionmethods and no params
public IActionResult CreateBook(...)
{
   // ...
}

[Route("[controller]/[action]")]
public class BooksController : Controller
{



+++++++++
MapControllerRoute:
Uses conventional routing (most often used in an MVC application), and sets up the URL route pattern. So you will have seen this in tutorials/documentation with something like this:

endpoints.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
You could set this to whatever you wanted (within reason) and your routes would follow this pattern. The above pattern is basically {{root_url}}/{{name_of_controller}}/{{name_of_action}}/{{optional_id}} where, if controller and action are not supplied, it defaults to home/index.

MapDefaultControllerRoute() This is the above, but it shorthands the configuration of the default pattern that I displayed above.

MapControllers This doesn't make any assumptions about routing and will rely on the user doing attribute routing (most commonly used in WebAPI controllers) to get requests to the right place.

N.B. It's entirely possible to use MapControllerRoute (and by proxy MapDefaultControllerRoute) along side attribute routing as well. If the user does not supply attributes, it will use the defined default pattern.
+++++++++++

app.UseEndpoints(endpoints => { endpoints.MapControllerRoute( name: "default", pattern: "{controller=Home}/{action=Index}/{id?}"); });

app.UseMvc(routes => { routes.MapRoute( name: "default", template: "{controller=Home}/{action=Index}/{id?}"); });

If you want to use the old routing system - use UseMvc and set EnableEndpointRouting = false. If you want to use the new routing system, use UseRouting and UseEndpoints and don't disable the new routing system

// The equivalent of 'app.UseMvcWithDefaultRoute()'::
        app.UseEndpoints(endpoints =>
        {
            endpoints.MapDefaultControllerRoute();
            // Which is the same as the template
            endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
        });
		
services.AddMvc(options => options.EnableEndpointRouting = false);
//OR
services.AddControllers(options => options.EnableEndpointRouting = false);

-----------
MapControllerRoute:

It adds endpoints for controller actions to Microsoft.AspNetCore.Routing.IEndpointRouteBuilder and specifies a route with the given name, pattern, defaults, constraints, and data tokens. The URL pattern constructs the route (conventional routing), usually used in MVC projects.

endpoints.MapControllerRoute(
  name:"default",
  pattern:"{controller=Home}/{action=index}/{id?}"
);

It was used in the early MVC web projects. Nowadays, conventional routing is not the mainstream, because the so-called conventional routing is not friendly to user browsing. 

Actually, Users should not be allowed to URL to match the developer-defined Controller-Action name, Instead, let developers match what users want to use URL, In this way, feature routing appears.



endpoints.MapDefaultControllerRoute():
//app.UseMvcWithDefaultRoute()

It is a shorthand for the configuration of the above default pattern. It ad the above default route internally by default. So MapDefaultControllerRoute is basically the same as MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}"). 

In the above both patterns are basically:

 {{root_url}}/{{name_of_controller}}/{{name_of_action}}/{{optional_id}} 

where, if controller and action are not supplied, it defaults to home/index.

MapControllers:

It adds endpoints for controller actions to Microsoft.AspNetCore.Routing.IEndpointRouteBuilder without specifying any routes. Make no assumptions about the agreed route,.
This doesn't make any assumptions about routing and will rely on the USER DOING ATTRIBUTE ROUTING (most commonly used in WebAPI controllers) to get requests to the right place.

It does not use conventional routing, instead, it is user-dependent feature routing used in Web API.

╔══════════════════════════════════════════╦═══════════════════════════════════════╗
║             app.UseRouting()             ║          app.UseEndPoints()           ║
╠══════════════════════════════════════════╬═══════════════════════════════════════╣
║               Find Endpoint              ║           Execute Endpoint            ║
║                                          ║                                       ║
║  Adds route MATCHING to the middleware   ║  Adds endpoint EXECUTION to the       ║
║  pipeline. This middleware looks at the  ║  middleware pipeline.                 ║
║  set of endpoints defined in the app,    ║  It runs the delegate associated      ║
║  and selects the best match based        ║  with the selected endpoint.          ║
║  on the request.                         ║                                       ║
║                                          ║                                       ║
╚══════════════════════════════════════════╩═══════════════════════════════════════╝
Based above table we should take care about some tips:

If the app calls UseStaticFiles, place UseStaticFiles before UseRouting.

it's important that you place the Authentication and Authorization middleware between UseRouting and UseEndPoints .

Any middleware that appears after the UseRouting() call will know which endpoint will run eventually.

Any middleware that appears before the UseRouting() call won't know which endpoint will run eventually.
----------------------------------------------------------------
app.UseRouting vs app.UseEndPoints:
The middleware added by UseRouting() calculates what route should be used for a request URL path, but doesn't route at this point in the pipeline. It adds metadata that can be used by subsequent middleware.

The middleware added by UseEndpoints() executes the Controller and corresponding handler.

UseEndpoints() is also where you actually register all the endpoints for your application
----------------------------------
ALL ABOUT DBCONTEXT???????




private ApplicationDbContext _db; ctr(_db)..

builder.Services.AddDbContext<ApplicationDbContext>(options => options.UseSqlServer(       
builder.Configuration.GetConnectionString("DefaultConnection")       
));

public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options)
        {

        }

        public DbSet<Book> Books { get; set; }
        public DbSet<UserModel> Users { get; set; }
----------------------------------
Eager loading: 
Eager loading in .NET Core is the process of loading related entities along with the main entity. This is achieved using the Include method, which returns the related entities as part of the query
Eager loading is the process whereby a query for one type of entity also loads related entities as part of the query, so that we don't need to execute a separate query for related entities. Eager loading is achieved using the Include() method
LINQ Query Syntax:

using (var context = new SchoolDBEntities())
{
    var stud1 = (from s in context.Students.Include("Standard")
                where s.StudentName == "Bill"
                select s).FirstOrDefault<Student>();
}
LINQ Method Syntax:

using (var ctx = new SchoolDBEntities())
{
    var stud1 = ctx.Students
                   .Include("Standard")
                   .Where(s => s.StudentName == "Bill")
                   .FirstOrDefault<Student>();
}
----------------------------------
EF core LAZY LOADING Apis:

Lazy loading of data is a pattern whereby the retrieval of data from the database is deferred until it is needed. This sounds like a good thing, and in some scenarios, this can help to improve the performance of an application. In other scenarios, it can degrade the performance of an application substantially, particularly so in web applications. For this reason, lazy Loading was introduced in EF Core 2.1 as an opt-in feature

1. Proxies: Proxies are objects deriving from your entities that are generated at runtime by Entity Framework Core. These proxies have behavior added to them that results in database query being made as required to load navigation properties on demand. This was the default mechanism used to provide lazy loading in the previous version of Entity Framework.

Install the Microsoft.EntityFrameworkCore.Proxies package
[Package Manager Console]
install-package Microsoft.EntityFrameworkCore.Proxies
[Dotnet CLI]
add package Microsoft.EntityFrameworkCore.Proxies
Use the UseLazyLoadingProxies method to enable the creation of proxies in the OnConfiguring method of the DbContext:
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.UseLazyLoadingProxies();
}
Make all navigation properties virtual:
public class Author
{
    public int AuthorId { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public virtual List<Book> Books { get; set; } = new List<Book>();
}
public class Book
{
    public int BookId { get; set; }
    public string Title { get; set; }
    public int AuthorId { get; set; }
    public virtual Author Author { get; set; }
}
This last step is the key to allowing EF Core to override your entities to create proxies. In addition, all entity types must be public, unsealed, and have a public or protected constructor.

ILazyLoader 
The ILazyLoader interface represents a component that is responsible for loading navigation properties if they haven't already been loaded. This approach circumvents the generation of proxies which isn't supported on all platforms. ILazyLoader can be used in one of two ways. It can be injected into the principal entity in the relationship, where it is used to load dependants. This requires that your model class(es) take a dependency on Microsoft.EntityFrameworkCore.Infrastructure, which is available in the Microsoft.EntityFrameworkCore.Abstractions package. Or you can use a convention-based delegate.

The following steps detail how to employ the first approach:

Install the Microsoft.EntityFrameworkCore.Abstractions package into the project containing your model classes:

[Package Manager Console]
install-package Microsoft.EntityFrameworkCore.Abstractions
[Dotnet CLI]
add package Microsoft.EntityFrameworkCore.Abstractions
Alter the principal entity to include

a using directive for Microsoft.EntityFrameworkCore.Infrastructure

a field for the ILazyLoader instance

an empty constructor, and one that takes an ILazyLoader as a parameter (which can be private, if you prefer)

a field for the collection navigation property

a getter in the public property that uses the ILazyLoader.Load method

using Microsoft.EntityFrameworkCore.Infrastructure;
public class Author
{
    private readonly ILazyLoader _lazyLoader;
    public Author()
    {
    }
    public Author(ILazyLoader lazyLoader)
    {
        _lazyLoader = lazyLoader;
    }
    private List<Book> _books;
    public int AuthorId { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public List<Book> Books
    {
        get => _lazyLoader.Load(this, ref _books);
        set => _books = value;
    }
}
Whether you have used proxies or the ILazyLoader interface, lazy loading is now enabled in your application, and will take place as soon as you reference dependent entities in a relationship:

using(var db = new BookContext())
{
    var authors = db.Authors;
    foreach(var author in authors)
    {
        Console.WriteLine($"Name: {author.FirstName} {author.LastName}");
        foreach(var book in author.Books) // lazy loading initiated
        {
            Console.WriteLine($"\t{book.Title}");
        }
    }
}
----------------------------------
Need of startup.cs file?
or
ConfigureServices vs Configure methods

ConfigureServices: The file helps us to configure DI object (services register)
Configure: helps us to configure middleware(request response pipeline)
----------------------------------
Filters in .net:

OtherMiddlewares->RoutingMiddleware->ActionSelection->MVCActionInvocationPipeline(Filter Pipeline)

Filters allow us to RUN CUSTOM CODE BEFORE or AFTER executing the action method. They provide ways to do common repetitive tasks on our action method. The filters are invoked on certain stages in the request processing pipeline.
 
There are many built-in filters available with ASP.NET Core MVC[Authorization(auth),Resource(caching), Action(manipulate Arg), Exception(handling), Type(similar to ServiceFilterAttribute; type need to be registered first), Result(after controller action success)], and we can create custom filters as well. Filters help us to remove duplicate codes in our application

OnActionExecuting->OnActionExecuted

add filters: builder.service....
services.AddControllers(options=>options.Filters.Add(new MySampleActionFilter())); //adds filter into the pipeline GLOBAL filter or any endpoint! ALL controllers


If you want to globally apply a filter to all controllers, you can use the services.AddControllers(options => options.Filters.Add(...)) approach. This means that ServiceExceptionInterceptor will be applied to all actions in all controllers.
If you want to apply a global filter to all requests (not just controllers), you can use app.UseEndpoints(...) with .WithEndpointFilter(...). This will apply the SampleGlobalFilter to all endpoints, which includes not only controllers but also other types of routes defined in your application.
In summary, it depends on the specific behavior you want to achieve. If you only want to apply a filter to controllers, use services.AddControllers(...) with the filter. If you want to apply a global filter to all routes, including non-controller routes, use app.UseEndpoints(...) with .WithEndpointFilter(...).



Also done for particular controller or action but use attribute!:
public class MySampleActionFilterAttribute : Attribute,IActionFilter
{}
and comment out global filter applied //
Now on top of controller:
[MySampleActionFilter("controller")] //this passed "string" logc can be implemented

Same can be done for action methods also

can be done for async:
public class MySampleAsyncActionFilter : IAsyncActionFilter
{
	public async Task OnActionExecution Async(ActionExecutingContext context, ActionExecutionDelegate next)
	{
			Console.WriteLine("b4");
			await next()
			Console.WriteLine("After");
	}
}
SAME WAY ABOVE AS ATTRIBUTE

FOR CHANGING ORDER: IOrderedFilter 
implement the order{get;set;}
int ctor(.., int order=0){}
+++++++++++++
Authorization filters
The Authorization filters are executed first. This filter helps us to determine whether the user is authorized for the current request. It can short-circuit a pipeline if a user is unauthorized for the current request. We can also create custom authorization filter.
Step 6

Open web.config file and write the following code under the system.web section.
<authentication mode="Forms">  
     <forms loginUrl="/Home/Login"></forms>  
</authentication>
[Authorize]  
        public ActionResult Secured()  
        {  
            return View();  
        }  
[AllowAnonymous]  
public ActionResult NonSecured()  
{  
    return View();  
}

Custom authorization filter:
public class CustomAuthorizationFilterAttribute : Attribute, IAuthorizationFilter
    {
        public void OnAuthorization(AuthorizationFilterContext context)
        {
            string currentUserRole = Convert.ToString(context.HttpContext.Session.GetString("UserRole"));

            if (!string.IsNullOrEmpty(currentUserRole))
            {
                if (currentUserRole != "Admin")
                {
                    context.Result = new RedirectToRouteResult
                (
                new RouteValueDictionary(new
                {
                    action = "Error",
                    controller = "Error"
                }));

                }
                else
                {
                    context.Result = new RedirectToRouteResult
               (
               new RouteValueDictionary(new
               {
                   action = "Error",
                   controller = "Error"
               }));

                }
            }
            else
            {
                context.Result = new RedirectToRouteResult
                (
                new RouteValueDictionary(new
                {
                    action = "Error",
                    controller = "Error"
                }));

            }
        }
    }
}
How to Apply Filter on Controller

using System;
using Microsoft.AspNetCore.Mvc;
using WebApplication4.Filters;

namespace WebApplication4.Controllers
{
    [TypeFilter(typeof(CustomAuthorizationFilterAttribute))]
    public class DefaultController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }
    }
}
+++++++++++++++
Resource filters
The Resource filters handle the request after authorization. It can run the code before and after the rest of the filter is executed. This executes before the model binding happens. It can be used to implement caching.

namespace WebApplication4.Filters
{
    public class CustomResourceFilter : Attribute, IResourceFilter
    {
        private readonly string[] _headers;

        public CustomResourceFilter(params string[] headers)
        {
            _headers = headers;
        }
        public void OnResourceExecuted(ResourceExecutedContext context)
        {

        }

        public void OnResourceExecuting(ResourceExecutingContext context)
        {
            if (_headers == null) return;

            if (!_headers.All(m => context.HttpContext.Request.Headers.ContainsKey(m)))
            {
                context.Result = new JsonResult(
                    new { Error = "Headers Missing" }
                )
                { StatusCode = 400 };
                ;
            }
        }
    }
}
Next, we are going to apply this filter on Post method of Default controller API and pass names of the header as string array which are required.

Code Snippet of Default1Controller

using Microsoft.AspNetCore.Mvc;
using WebApplication4.Filters;
using WebApplication4.Models;

namespace WebApplication4.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class Default1Controller : ControllerBase
    {

        // POST: api/Default1
        [HttpPost]
        [CustomResourceFilter("X-Value", "Y-Value")]
        public void Post([FromBody] UserRoles value)
        {

        }
    }
}

+++++++++++++++
Action filters
The Action filters run the code immediately before and after the controller action method is called. It can be used to perform any action before or after execution of the controller action method. We can also manipulate the arguments passed into an action.

builder.Services.AddScoped<ActionFilter>(); 
builder.Services.AddScoped<ControllerFilterExample>();
or
builder.Services.AddControllers(config => 
{ 
    config.Filters.Add(new GlobalFilterExample()); 
});

public class ActionFilter : Attribute, IActionFilter
{
   public void OnActionExecuted(ActionExecutedContext context) {}
   
   // Pull the user ID on each request
   public void OnActionExecuting(ActionExecutingContext context
   {
      var c = context.Controller as ApiController;
      c.UserId = c.User.FindFirstValue(ClaimTypes.NameIdentifier);
   }
}

ApiController]
[Authorize] // Uses authentication scheme to determine user
[ActionFilter] // We will implement this below
public abstract class ApiController : ControllerBase
{
   public string UserId { get; set; }
}
+++++++++++++++
Exception filters
The Exception filters are used to handle exception that occurred before anything written to the response body.

public class ServiceExceptionInterceptor : IExceptionFilter
    {
        public void OnException(ExceptionContext context)
        {
            var error = new ErrorDetails()
            {
                StatusCode = 500,
                Message = "Something went wrong! Internal Server Error."
            };
 
            //Logs your technical exception with stack trace below
            context.Result = new JsonResult(error);
        }
    }
	
3.0 or below
public void ConfigureServices(IServiceCollection services)
       {
           services.AddMvc(options => options.Filters.Add(new 
           ServiceExceptionInterceptor()));
       }
	   
For .NET Core 3.1 and above version

services.AddControllers(options => options.Filters.Add(new
ServiceExceptionInterceptor()));

What is TypeFilter?

TypeFilter is a filter of type Microsoft.AspNetCore.Mvc.TypeFilterAttribute.ImplementationType.
It retrieves missing constructor arguments from dependency injection if available.

[TypeFilter(typeof(ServiceExceptionInterceptorAsync))]
public IEnumerable<WeatherForecast> Get()
{


+++++++++++++++
Result filters
The Result filters are used to run code before or after the execution of controller action results. They are executed only if the controller action method has been executed successfully.

REQUEST->AuthF->ResourceF(onActionExecuting)->ActionF(onActionExecuting)->ActionExecution->ResultF->ActionF(onActionExecuted)->ResourceF(onActionExecuted)->RESPONSE

The Synchronous filters run the code before and after their pipeline stage defines OnStageExecuting and OnStageExecuted. For example, ActionFilter. The OnActionExecuting method is called before the action method and OnActionExecuted method is called after the action method.
 
Synchronous Filter Example
using Microsoft.AspNetCore.Mvc.Filters;  
namespace Filters  
{  
    public class CustomActionFilter : IActionFilter  
    {  
        public void OnActionExecuting(ActionExecutingContext context)  
        {  
            //To do : before the action executes  
        }  
  
        public void OnActionExecuted(ActionExecutedContext context)  
        {  
            //To do : after the action executes  
        }  
    }  
}  
Asynchronous filters are defined with only single method: OnStageExecutionAsync, that takes a FilterTypeExecutingContext and FilterTypeExecutionDelegate as The FilterTypeExecutionDelegate execute the filter’s pipeline stage. For example, ActionFilter ActionExecutionDelegate calls the action method and we can write the code before and after we call action method.
 
Asynchronous filter example
using System.Threading.Tasks;  
using Microsoft.AspNetCore.Mvc.Filters;  
  
namespace Filters  
{  
    public class CustomAsyncActionFilter : IAsyncActionFilter  
    {  
        public async Task OnActionExecutionAsync(ActionExecutingContext context,  ActionExecutionDelegate next)  
        {  
            //To do : before the action executes  
            await next();  
            //To do : after the action executes  
        }  
    }  
}  

Adding Filter scope and Order of execution

A filter can be added to the pipeline at one of three scopes: by action method, by controller class or globally (which be applied to all the controller and actions). We need to register filters in to the MvcOption.Filters collection within ConfigureServices method.
public void ConfigureServices(IServiceCollection services)  
{  
    // Add framework services.  
    services.AddMvc(options=> {  
    //an instant  
    options.Filters.Add(new CustomActionFilter());  
    //By the type  
    options.Filters.Add(typeof(CustomActionFilter));  
    });  
}  
When multiple filters are applied to the particular stage of the pipeline, scope of filter defines the default order of the filter execution. The global filter is applied first, then class level filter is applied and finally method level filter is applied.

GlobalFilter(OnStageExecuting)->ControllerClassF(OnStageExecuting)->MethodFilter(OnStageExecuting)->ActionMethodExecution->MethodFilter(OnStageExecuted)->ControllerClassF(OnStageExecuted)->GlobalFilter

Overriding the default order

We can override the default sequence of filter execution by using implementing interface IOrderedFilter
public class ExampleFilterAttribute : Attribute, IActionFilter, IOrderedFilter  
    { 
	
 [ExampleFilter(Order = 1)]  
    public class HomeController : Controller  
    {  
        public IActionResult Index()  
        {  
            return View();  
        }  
    }  

NOTE::::::::::::::::::
Cancellation or short circuiting filters
We can short circuit the filter pipeline at any point of time by setting the "Result" property of the "Context" parameter provided to the filter's methods.
 
Filter Example
using System;  
using Microsoft.AspNetCore.Mvc;  
using Microsoft.AspNetCore.Mvc.Filters;  
namespace Filters  
{  
    public class Example1FilterAttribute : Attribute, IActionFilter  
    {  
        public void OnActionExecuting(ActionExecutingContext context)  
        {  
            //To do : before the action executes  
            context.Result = new ContentResult()  
            {  
                Content = "Short circuit filter"  
            };  
        }  
        public void OnActionExecuted(ActionExecutedContext context)  
        {  
            //To do : after the action executes  
        }  
    }  
}  
++++++++++++++++++++++++
If Service injected then register and use:

[ServiceFilter(typeof(ExampleFilterWithDI))]  
public IActionResult Index()  
{  
    return View();  
} 

public void ConfigureServices(IServiceCollection services)  
{  
    services.AddScoped<ExampleFilterWithDI>();  
}  

+++++++++++++++++++++++++
TypeFilterAttribute

It is very similar to ServiceFilterAttribute and also implemented from IFilterFactory interface. Here, type is not resolved directly from the DI container but it instantiates the type using class "Microsoft.Extensions.DependencyInjection.ObjectFactory".

Due to this difference, the types are referenced in TypeFilterAttribute need to be register first in ConfigureService method. The "TypeFilterAttribute" can be optionally accept constructor arguments for the type. Following example demonstrates how to pass arguments to a type using TypeFilterAttribute.
[TypeFilter(typeof(ExampleFilterAttribute), Arguments = new object[] {"Argument if any" })]  
public IActionResult About()  
{  
    return View();  
}   



-----------------------------'
GLOBAL Exception Filter:
First we need to create a class that will inherit IExceptionFilter declared in the namespace "Microsoft.AspNetCore.Mvc.Filters" and implement the OnException method of the interface.



public class GlobalExceptionFilters : IExceptionFilter
    {
        private readonly ILogger _logger;


        public GlobalExceptionFilters(ILogger<GlobalExceptionFilters> logger)
        {
            _logger = logger;
        }


        public void OnException(ExceptionContext context)
        {
            if (!context.ExceptionHandled)
            {
                var exception = context.Exception;


                int statusCode;


                switch (true)
                {
                    case bool _ when exception is UnauthorizedAccessException:
                        statusCode = (int)HttpStatusCode.Unauthorized;
                        break;


                    case bool _ when exception is InvalidOperationException:
                        statusCode = (int)HttpStatusCode.BadRequest;
                        break;


                    default:
                        statusCode = (int)HttpStatusCode.InternalServerError;
                        break;
                }


                _logger.LogError($"GlobalExceptionFilter: Error in {context.ActionDescriptor.DisplayName}. {exception.Message}. Stack Trace: {exception.StackTrace}");


                // Custom Exception message to be returned to the UI
                context.Result = new ObjectResult(exception.Message) { StatusCode = statusCode };
            }
        }
    }

Register:
	
	 services.AddMvc(options =>
            {
                options.Filters.Add(typeof(GlobalExceptionFilters));
            })
----------------------------------
EXCEPTION HANDLING IN .net core:
https://www.c-sharpcorner.com/article/exception-handling-3-in-asp-net-core-mvc/#:~:text=Approach%201%3A%20UseExceptionHandler,-1%3A%20Exception%20Handler&text=For%20Production%20environment%2C%20startup%20file,)%3B%20%7D%20else%20%7B%20app.

In .NET Core, there are several ways to handle exceptions and manage error scenarios. Here are some commonly used approaches for exception handling:

Try-Catch Blocks:
Using try-catch blocks allows you to catch and handle exceptions within a specific code block. This approach is suitable for handling exceptions in a localized manner. Here's an example:

try
{
    // Code that may throw an exception
}
catch (Exception ex)
{
    // Exception handling logic
}
You can catch specific types of exceptions by specifying the desired exception type in the catch block, allowing you to handle different exceptions differently.

Global Exception Handling Middleware:
In ASP.NET Core, you can use middleware to globally handle exceptions. By adding custom exception handling middleware, you can catch and process exceptions that occur during the request pipeline. This approach centralizes error handling and allows you to provide a consistent error response to clients. Here's an example of setting up global exception handling middleware:

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // Other middleware configuration

    app.UseExceptionHandler("/Home/Error");
    app.UseStatusCodePagesWithRedirects("/Home/Error/{0}");
    // More middleware configuration
}
In the above example, the UseExceptionHandler middleware is added, specifying the PATH TO THE ERROR HANDLING CONTROLLER ACTION.

Exception Filters:
Exception filters provide a way to handle exceptions at the action or controller level. By implementing an exception filter, you can define custom logic to handle exceptions that occur within specific actions or controllers. Here's an example:
app.UseExceptionHandler("/Home/Error") is setting up a global exception handling middleware. If an unhandled exception occurs, it will redirect to the /Home/Error route.

app.UseStatusCodePagesWithRedirects("/Home/Error/{0}") is setting up a middleware to handle specific HTTP status codes. In this case, it's set up to redirect to the /Home/Error/{0} route when a status code indicates an error.

public class CustomExceptionFilter : IExceptionFilter
{
    public void OnException(ExceptionContext context)
    {
        // Exception handling logic
    }
}
You can apply the exception filter globally or selectively to specific actions or controllers.

Use of Response StatusCode and Content:
Another approach is to catch exceptions and return appropriate HTTP status codes and error messages directly within your action methods. This approach allows you to provide fine-grained control over the error response. Here's an example:


public IActionResult MyAction()
{
    try
    {
        // Code that may throw an exception
        return Ok();
    }
    catch (Exception ex)
    {
        return StatusCode(StatusCodes.Status500InternalServerError, "An error occurred.");
    }
}
In the catch block, you can return an appropriate HTTP status code along with an error message or content.

These are some of the commonly used ways to handle exceptions in .NET Core applications. The choice of approach depends on the specific requirements of your application and the level of control you need over exception handling
----------------------------------
Global Exception handling using custom middleware:

Global exception handling in .NET Core is the process of intercepting any unhandled exceptions that occur in an application and providing a central location for handling those exceptions. This approach helps to improve the reliability and stability of the application by preventing crashes and error messages from being displayed to the user.

There are several ways to implement global exception handling in .NET Core, including using MIDDLEWARE, FILTERS, and LOGGING PROVIDERS. One of the most common approaches is to use middleware, which allows you to catch exceptions that occur during the request pipeline and perform custom error handling.

public class ExceptionMiddleware
{
    private readonly RequestDelegate _next;

    public ExceptionMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            // Log the exception
            ILogger<ExceptionMiddleware> logger = context.RequestServices.GetRequiredService<ILogger<ExceptionMiddleware>>();
            logger.LogError(ex, "An error occurred while processing the request.");

            // Return a user-friendly error message to the client
            context.Response.ContentType = "application/json";
            context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
            await context.Response.WriteAsync(JsonConvert.SerializeObject(new { error = "An unexpected error occurred. Please try again later." }));
        }
    }
}
You can then register the middleware in the Configure method of the Startup class:

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // Other middleware...
    
    app.UseMiddleware<ExceptionMiddleware>();
    
    // Other middleware...
}

----------------------------------
Using Exception filter to handle exception:

public class CustomExceptionFilter : IExceptionFilter
{
    public void OnException(ExceptionContext context)
    {
        // Log the exception
        ILogger logger = context.HttpContext.RequestServices.GetService<ILogger<CustomExceptionFilter>>();
        logger.LogError(context.Exception, "An error occurred while processing the request.");

        // Return a user-friendly error message to the client
        context.Result = new JsonResult(new { error = "An unexpected error occurred. Please try again later." })
        {
            StatusCode = StatusCodes.Status500InternalServerError
        };
    }
}
In the OnException method, you can log the exception and return a user-friendly error message to the client. In this example, the error message is returned as a JSON object with a status code of 500.

Once you have created your custom error filter class, you can add it to the MVC pipeline by registering it in the Startup class ConfigureServices method:

											services.AddControllersWithViews(options =>
											{
												options.Filters.Add(typeof(CustomExceptionFilter));
											});
In this example, the CustomExceptionFilter class is added to the Filters collection of the options parameter of the AddControllersWithViews method.

By adding an error filter to the MVC pipeline, any exceptions that occur during the processing of a request will be intercepted and handled by the error filter. This provides a centralized location for handling exceptions and returning user-friendly error messages to the client.

ANOTHER WAY OF USING EXCEPTIONFILTER [NICE WAY!!!]:------------

Step 1

Create an Custom Exception Filter: CustomExceptionFilter

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.AspNetCore.Mvc.ModelBinding;
using Microsoft.AspNetCore.Mvc.ViewFeatures;

namespace ErrorHandlingSample.Filters
{
    public class CustomExceptionFilter : IExceptionFilter
    {
        private readonly IModelMetadataProvider _modelMetadataProvider;

        public CustomExceptionFilter(IModelMetadataProvider modelMetadataProvider)
        {
            _modelMetadataProvider = modelMetadataProvider;
        }

        public void OnException(ExceptionContext context)
        {
            var result = new ViewResult { ViewName = "CustomError" };
            result.ViewData = new ViewDataDictionary(_modelMetadataProvider, context.ModelState);
            result.ViewData.Add("Exception", context.Exception);

            // Here we can pass additional detailed data via ViewData
            context.ExceptionHandled = true; // mark exception as handled
            context.Result = result;//redirect to the view CustomError
        }
    }
}
C#
Step 2

Create a CustomError view: View/Shared/CustomError.cshtml

@{
    ViewData["Title"] = "CustomError";
    var exception = ViewData["Exception"] as Exception;
}

<h1>An Error has Occurred</h1>

<p>@exception.Message</p>
Step 3

Register in either locally in Controller level or Action level, e.g.

[TypeFilter(typeof(CustomAsyncExceptionFilter))]
public IActionResult Failing()
{
    throw new Exception("Testing custom exception filter.");
}
C#
or global level in startup.ConfigureService,

public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();

    services.AddControllersWithViews(config => config.Filters.Add(typeof(CustomExceptionFilter)));
	//options =>{options.Filters.Add(typeof(CustomExceptionFilter));});
	//services.AddScoped<CustomActionFilter>();

}

services.AddScoped<CustomActionFilter>() and services.AddControllersWithViews(config => config.Filters.Add(typeof(CustomExceptionFilter))) are both registration statements in ASP.NET Core's dependency injection container, but they serve different purposes:

services.AddScoped<CustomActionFilter>():

This registers CustomActionFilter as a service with scoped lifetime in the dependency injection container. This means that a new instance of CustomActionFilter will be created for each HTTP request, and it will be disposed of at the end of the request.

CustomActionFilter is likely an implementation of an action filter. Action filters are used to perform logic before or after an action method is executed.

services.AddControllersWithViews(config => config.Filters.Add(typeof(CustomExceptionFilter))):

This configures the MVC services and adds controllers with views. Additionally, it specifies that CustomExceptionFilter should be added to the global list of filters.

CustomExceptionFilter is likely an implementation of an exception filter. Exception filters are used to handle exceptions that occur during the processing of an action method.

In summary, the two registration statements are for different types of filters:

CustomActionFilter is registered as a scoped service and is likely an action filter.
CustomExceptionFilter is added as a global filter for all controllers and is likely an exception filter.
These filters serve different purposes in the request processing pipeline. Action filters execute code before and/or after action methods, while exception filters handle exceptions that occur during action execution.







C#
Run the app, and Test it: Click Trigger an exception (you must either register the Exception filter locally in Action or Controller or Globally):


A filter can be added to the pipeline at one of three scopes:

1.Using an attribute on a controller or Razor Page.
2.Using an attribute on a controller action. Filter attributes cannot be applied to Razor Pages handler methods.
3.Globally for all controllers, actions, and Razor Pages as shown in the following code:

Cancellation and short-circuiting
The filter pipeline can be short-circuited by setting the Result property on the ResourceExecutingContext parameter provided to the filter method. For example, the following Resource filter prevents the rest of the pipeline from executing:


C#

public class ShortCircuitingResourceFilterAttribute : Attribute, IResourceFilter
{
    public void OnResourceExecuting(ResourceExecutingContext context)
    {
        context.Result = new ContentResult
        {
            Content = nameof(ShortCircuitingResourceFilterAttribute)
        };
    }

    public void OnResourceExecuted(ResourceExecutedContext context) { }
}
In the following code, both the [ShortCircuitingResourceFilter] and the [ResponseHeader] filter target the Index action method. The ShortCircuitingResourceFilterAttribute filter:

Runs first, because it's a Resource Filter and ResponseHeaderAttribute is an Action Filter.
Short-circuits the rest of the pipeline.
Therefore the ResponseHeaderAttribute filter never runs for the Index action. This behavior would be the same if both filters were applied at the action method level, provided the ShortCircuitingResourceFilterAttribute ran first. The ShortCircuitingResourceFilterAttribute runs first because of its filter type:

C#

Copy
[ResponseHeader("Filter-Header", "Filter Value")]
public class ShortCircuitingController : Controller
{
    [ShortCircuitingResourceFilter]
    public IActionResult Index() =>
        Content($"- {nameof(ShortCircuitingController)}.{nameof(Index)}");
}


//[ServiceFilter(typeof(typeof YourActionFilter))]
//also register filter:
services.AddScoped<CustomActionFilter>();
services.AddControllersWithViews();

----------------------------------
[ChildActionOnly]
 attribute is used to make sure that an Action method is only called from inside the View and cannot be access directly by the User.
 Generally it is used for Action methods invoked by Partial Views. It is not necessary to have this attribute over a Child Action method. But as a good practice it is recommended.
 An action method can be a child or a normal action method, but child actions are action methods invoked from within a view, you cannot invoke a child action method via user request (URL).
We can annotate an action method with the [ChildActionOnly] attribute to create a child action. Normally we use child action methods with partial views.
Thus [ChildActionOnly] is an attribute when it is preceded over any controller action method. After this, the method could not make a request from the browser, it can only be called from a View.
@html.Action()
@html.RenderAction()
 
Partial View:
public ActionResult Index()
    {
        NorthwindEntities entities = new NorthwindEntities();
        return View(from customer in entities.Customers.Take(10)
                    select customer);
    }
 
[ChildActionOnly]
public ActionResult Details(string customerId)
    {
        NorthwindEntities entities = new NorthwindEntities();
        return PartialView("Details", entities.Customers.Find(customerId));
    }

@Html.Action("Details", new { CustomerId = customer.CustomerID })

pertial view:
@model Partial_View_Entity_MVC.Customer
 
@Html.DisplayFor(model => model.Address)
<br/>
@Html.DisplayFor(model => model.City),
@Html.DisplayFor(model => model.PostalCode)
<br/>
@Html.DisplayFor(model => model.Country)

view:
@model IEnumerable<PartialView_Action_MVC.Customer>
 
@{
    Layout = null;
}
 
<!DOCTYPE html>
 
<html>
<head>
    <meta name="viewport" content="width=device-width"/>
    <title>Index</title>
</head>
<body>
    <h4>Customers</h4>
    <hr/>
    <table cellpadding="0" cellspacing="0" id="CustomerGrid">
        <tr>
            <th>CustomerID</th>
            <th>Contact Name</th>
            <th>Address</th>
        </tr>
        @foreach (Customer customer in Model)
        {
            <tr>
                <td>@customer.CustomerID</td>
                <td>@customer.ContactName</td>

                <td>@Html.Action("Details", new { CustomerId = customer.CustomerID })</td>

            </tr>
        }
    </table>
</body>
</html>
++++++++++++++++++++++++++++++
HTML helper has two methods for rendering the partial view: Partial and RenderPartial.
<div>  
    @Html.Partial("PartialViewExample")  
</div>  
<div>  
    @{  
        Html.RenderPartial("PartialViewExample");  
    }  
</div> 

@Html.Partial("PartialViewExample");
	This method renders the view as an HTML-encoded string. We can STORE THE METHOD RESULT IN A STRING VARIABLE.
Html.RenderPartial("PartialViewExample"); 
	The result of the RenderPartial method is written DIRECTLY INTO THE HTTP RESPONSE, it means that this method used the same TextWriter object as used by the current view. This method returns nothing. The Html.RenderPartial method writes output directly to the HTTP response stream so it is slightly faster than the Html.Partial method.
@Html.Action
	This Html.Action renders partial view as an HTML string so we can STORE IT IN ANOTHER STRING VARIABLE. It is string return type method so first it returns result as a string then renders result to response.
@Html.RenderAction
	This is also same as Html.Action but main difference is that it renders result directly to response that’s why it is more efficient if the action returns a large amount of HTML over @Html.Action.
+++++++++++++++++++++++++++++
Returning a Partial view from the Controller's Action method:
public ActionResult PartialViewExample()  
{  
    return PartialView();  
} 
Render Partial View Using jQuery
 
Sometimes we need to load a partial view within a model popup at runtime, in this case we can render the partial view using JQuery element's load method.
<script type="text/jscript">  
        $('#partialView').load('/shared/PartialViewExample’);  
</script> 
View Vs Partial View
 
View	Partial View
View contains the layout page
	Partial view does not contain the layout page
_viewstart page is rendered before any view is rendered	
	Partial view does not check for a _viewstart.cshtml. We cannot place any common code for a partial view within the _viewStart.cshtml page.
View may have markup tags like html, body, head, title, meta etc.	
	The Partial view is specially designed to render within the view and as a result it does not contain any mark up.
	Partial view is more lightweight than the view. WE CAN ALSO PASS A REGULAR VIEW TO THE RENDERPARTIAL METHOD.
If there is no layout page specified in the view, it can be considered as a partial view. 
In razor, there is no distinction between views and partial views(cshtml) as in the ASPX view engine (aspx and ascx).

+++++++++++++++++++++++++++++
CLARIFICATIONS(Html.Partial() vs Html.Action()):

Html.Partial: Render a Partial View without hitting a controller action first.
@Html.Partial("PartialViewExample");

Html.Action CALL A CONTROLLER ACTION, which may return a view/partial view (or may not, it could throw an HttpNotFound or return Json, or other things).
<td>@Html.Action("Details", new { CustomerId = customer.CustomerID })</td>

Does your menu require a view model, or is it static?

If it's a static menu, Html.Partial will fit your needs. Place the static menu content inside the partial view and call Html.Partial where you want it to render.

If the menu is being generated off a view model, you can use either Html.Partial or Html.Action:
----------------------------------
@Html.ActionLink("Application name", "Index", "Home", new { area = "" }, new { @class = "navbar-brand" })
@Html.ActionLink("Click here", // <-- Link text  
                 "About", // <-- Action Method Name  
                 "Home", // <-- Controller Name  
                 null, // <-- Route value  
                 null // <-- htmlArguments  
                 )  
----------------------------------
What is viewcomponent:
ViewComponents allow you to create reusable UI components that can be rendered within your views

Create a ViewComponent class:
using Microsoft.AspNetCore.Mvc;

public class HelloWorldViewComponent : ViewComponent
{
    public IViewComponentResult Invoke()
    {
        string message = "Hello, World!";
        return View("Default", message); // Renders the "Default" view with the message
    }
}
Create the corresponding view for the ViewComponent:
Under the Views folder, create a folder named "Shared" (if it doesn't already exist), and within that folder, create a view file named "Default.cshtml":

@model string

<p>@Model</p>
In your view or layout file, render the ViewComponent:

@await Component.InvokeAsync("HelloWorld")  //HelloWorldViewComponent

Register the ViewComponent in your application:
In the ConfigureServices method of your Startup.cs file, add the following code:

services.AddMvc();

Use the ViewComponent in a view:
Include the view or layout file where you added the:::: @await Component.InvokeAsync("HelloWorld") code. The ViewComponent will be invoked and rendered at that location.
In this example, when the ViewComponent is invoked, it sets the message "Hello, World!" and renders the "Default" view, passing the message as the model. The view then displays the message using @Model.

You can create multiple ViewComponents and reuse them across different views by invoking them using @await Component.InvokeAsync("ComponentName").

Remember to include the necessary namespaces and reference the required packages in your project.

----------------------------------

WHAT is Razor?

Razor is a VIEW ENGINE, it is a markup sytax which helps us to write html and server side code using c# or VB.net
We can mix up HTML and C# code

@{ int i=0;i++}
@DateTime.Now

WHAT IS VIEW ENGINE:
What is a view engine? A view engine translates a server-side template into HTML markup and renders it in the web browser when triggered by a controller's action method. ASP.NET MVC initially shipped with the ASPX View Engine, but the Razor View Engine was added in later versions
----------------------------------
HOW TO PASS MODEL object to a View:

public IActionResult Search ( string customerName ) // Do execute the
{
    // We are using the new keyword to create the object
    List <Customer> custs= (from temp in custDbContext.Customers
    where temp.customerName == customerName select temp).ToList<Customer>();
return View ("DisplayCustomer",custs); 
}

also 
@using PassDatainMVC.Models 
in the cshtml
----------------------------------
@model or @using:
Regarding the @model statement inside a view, there are essentially two options:

@using MyNamespace.MyNestedNamespace
@model MyModel
Or, if you think you will not need any other types from that namespace:

@model MyNamespace.MyNestedNamespace.MyModel
There is no real difference, is up to you what you think is better for that view.

Every time you need to IMPORT A NAMESPACE inside your view. This is the same as when you import a namespace in a standard C# code file.

So, if you need to use a type which is declared in a different namespace than the View one, you'll need to add a using statement before using that type
Aside from the answers above, you would typically use @using on creating form:

@using (Html.BeginForm("Upload", "Upload", FormMethod.Post, 
                                  new { enctype = "multipart/form-data" }))
{
//TODO: Logic here
}
This provides convenient syntax that ensures the correct use of IDisposable objects. 
----------------------------------
@model vs @Model:
@model is used to "import" a model in the view page while the @Model represents the imported model and is where you retrieve its properties.

See the example below:

@model MeuExemploMVC.Models.CarrinhoComprasViewModel

@{
    ViewBag.Title = "Purchase Cart";
}

<h2>@Model.Mensagem
</h2>
<fieldset>
    <legend>Purchase Cart</legend>

    <table>
        <caption>Products</caption>
        <thead>
        <tr>
            <th>Product</th>
            <th>Price</th>
        </tr>
        </thead>
        <tbody>
        @foreach (var product in Model.Products) {
            <tr>
                <td>@product.Name</td>
                <td>@product.Price</td>
            </tr>
        }
        </tbody>
        <tfoot>
            <tr>
                <td><strong>Total</strong></td>
                <td>@Model.TotalPrice</td>
            </tr>
        </tfoot>
    </table>

</fieldset>
Here you see that @model simply imports the Model object to the page while the @Model you get actual value from the retrieved model.
----------------------------------
Content Negotitation in web api:

We know that there are three pillars of the internet, they are:
The resource
The URL
The representation

For example, a few want data in normal HTML format and some in normal text format. Others need the JSON format and still others in XML format.
The formal definition of Content Negotiation is “the process of selecting the best representation for a given response when there are multiple representations available”.
Content-type: which requests to API to represent data in this type.
Accept: The acceptable media types for the response, such as “application/json,” “application/xml,” or a custom media type such as "application/vnd.example+xml".
Accept-Charset: The acceptable character sets, such as UTF-8 or ISO 8859-1.
Accept-Encoding: The acceptable content encodings, such as gzip.
Accept-Language: The preferred natural language, such as “en-us”.

++++++
User-Agent: Fiddler
Content-type: application/json
Host: localhost:11129
++++++
User-Agent: Fiddler
Content-type: application/xml
Host: localhost:11129
By checking the “Accept” header, the Web API understands which representation the client is able to accept. For example, if we specify that the client can understand the following representation:
application/xml , application/json, text/javascript
Then the Web API will return data in JSON format, the reason is JSON is the default format of the Web API, although the client’s first preference is the XML format. We will prove it with a small example
----------------------------------
Transaction Scope in c#:

Namespace Name: System.Transactions.TransactionScope
Definition: TransactionalScope makes your code block Transactional.
You can easily maintain one transaction for multiple databases or a single database with multiple connectionstrings, using TransactionScope.
When you use TransactionScope there is no need to close any Database connections in the middle.

Just make an object of the TransactionScope class with using. Write all your code in this block and after completion of all your operations call "objTransactionscope.complete()". Ensure one thing; you should write a try/catch block in the TransactionScope block.

Syntax to use TransactionScope
using (TransactionScope transactionScope = new TransactionScope())
{
    try
    {
        method1() // Oracle DML operation
        method2() // Sql DML operation
        method3() // Oracle DML operation
        // transactionScope.Complete()
        // transactionScope.Dispose();
    }
    catch (TransactionException ex)
    {
        transactionScope.Dispose();
        MessageBox.Show("Transaction Exception Occured");
    }
}
C#
Now if an exception occurrs in method1(), method2() or method3() then it will catch the exception in the catch block and all the operations will be rolled back automatically. There is no option to call a rollback manually in TransactionScope.

Take care of one thing, that there is no connection.close() or dispose() in any methods (1, 2 or 3) otherwise it will give you the error:

"the transaction has aborted"

when you call transactionScope.Dispose() after completion of all your objects that are used in this TransactionScope dispose.
----------------------------------
.net return type to return a large file:

In .NET Core, the FileStreamResult class is commonly used as the return type to efficiently serve large files. It allows you to read a file from disk and send it as a response without loading the entire file into memory.

using Microsoft.AspNetCore.Mvc;
using System.IO;

public class FileController : Controller
{
    public IActionResult DownloadFile()
    {
        // Path to the file on disk
        string filePath = "path_to_your_large_file";

        // Set the content type based on the file type
        string contentType = "application/octet-stream"; // Example content type, modify as needed

        // Return the file using FileStreamResult
        return new FileStreamResult(new FileStream(filePath, FileMode.Open, FileAccess.Read), contentType)
        {
            FileDownloadName = "filename.ext" // Set the desired file name seen by the client
        };
    }
}

also:
[FromQuery] - Gets values from the query string.
[FromRoute] - Gets values from route data.
[FromForm] - Gets values from posted form fields.
[FromBody] - Gets values from the request body.
[FromHeader] - Gets values from HTTP headers.
----------------------------------
Webapi vs restapi:

The terms "Web API" and "REST API" are often used interchangeably, but there are some differences between the two concepts. Let's clarify them:

Web API:

Web API refers to a general term for an application programming interface (API) that is exposed over the web using HTTP protocols.
It is a broad term that encompasses different types of APIs, including RESTful APIs.
Web APIs can follow various architectural styles, not just REST.
REST API (Representational State Transfer):

REST is an architectural style that provides a set of constraints and principles for designing networked applications.
RESTful APIs adhere to these principles and use HTTP as the primary protocol for communication.
REST APIs are designed around resources, which are identified by unique URIs (Uniform Resource Identifiers).
  They support standard HTTP methods like GET, POST, PUT, DELETE for CRUD operations on resources.
REST APIs are stateless, meaning each request from the client must contain all the necessary information for the server to understand and process it.
  They typically return responses in a format like JSON or XML.
In summary, a REST API is a specific type of Web API that follows the REST architectural principles. However, not all Web APIs are RESTful. Web APIs can use other architectural styles or custom protocols for communication, while REST APIs adhere to the specific constraints and principles of REST.
----------------------------------
Explain Strongly typed views?

Where we get intellisense for model inside razor pages
to create strongly typed:
at the top of razor page:

@model List<CustomerApp.Models.Customer>
----------------------------------
Whats viewModels?

Data what your view needs, in view we can only use one model
for getiing rid of this problem we use a viewModel or a WRAPPER CLASS:

public class CustomerViewModel{
public Customer customer{g;s;}
public List<Product> products{g;s;}
}
now:
@model FirstCoreMVCApplication.ViewModels.CustomerViewModel

MULTIPLE MODELS IN ONE VIEW::

In MVC we cannot pass multiple models from a controller to the single view. This article provides a workaround for multiple models in a single view in MVC.
+++++++++++++++++++++++++++
Problem Statement
Suppose I have two models, Teacher and Student, and I need to display a list of teachers and students within a single view. How can we do this?

The following are the model definitions for the Teacher and Student classes.

public class Teacher
{
    public int TeacherId { get; set; }
    public string Code { get; set; }
    public string Name { get; set; }
}

public class Student
{
    public int StudentId { get; set; }
    public string Code { get; set; }
    public string Name { get; set; }
    public string EnrollmentNo { get; set; }
}
C#
The following are the methods that help us to get all the teachers and students.

private List<Teacher> GetTeachers()
{
    List<Teacher> teachers = new List<Teacher>();
    teachers.Add(new Teacher { TeacherId = 1, Code = "TT", Name = "Tejas Trivedi" });
    teachers.Add(new Teacher { TeacherId = 2, Code = "JT", Name = "Jignesh Trivedi" });
    teachers.Add(new Teacher { TeacherId = 3, Code = "RT", Name = "Rakesh Trivedi" });
    return teachers;
}

public List<Student> GetStudents()
{
    List<Student> students = new List<Student>();
    students.Add(new Student { StudentId = 1, Code = "L0001", Name = "Amit Gupta", EnrollmentNo = "201404150001" });
    students.Add(new Student { StudentId = 2, Code = "L0002", Name = "Chetan Gujjar", EnrollmentNo = "201404150002" });
    students.Add(new Student { StudentId = 3, Code = "L0003", Name = "Bhavin Patel", EnrollmentNo = "201404150003" });
    return students;
}

There are many ways to use multiple models with a single view.
dynamic mymodel = new ExpandoObject();
        mymodel.Teachers = GetTeachers();
        mymodel.Teachers = GetStudents();

ViewModel mymodel = new ViewModel();
    mymodel.Teachers = GetTeachers();
    mymodel.Students = GetStudents();
    return View(mymodel);
	//public class ViewModel
		//{
		//	public IEnumerable<Teacher> Teachers { get; set; }
		//	public IEnumerable<Student> Students { get; set; }
		//}
		
ViewData["Teachers"] = GetTeachers();
    ViewData["Students"] = GetStudents();
    return View();//conversion to list<IEnumerable> in view
	
ViewBag.Teachers = GetTeachers();
    ViewBag.Students = GetStudents();
    return View();

1. Using Dynamic Model
ExpandoObject (the System.Dynamic namespace) is a class that was added to the .Net Framework 4.0 that allows us to dynamically add and remove properties onto an object at runtime. Using this ExpandoObject, we can create a new object and can add our list of teachers and students into it as a property. We can pass this dynamically created object to the view and render list of the teacher and student.

Controller Code

public class HomeController : Controller
{
    public ActionResult Index()
    {
        ViewBag.Message = "Welcome to my demo!";
        dynamic mymodel = new ExpandoObject();
        mymodel.Teachers = GetTeachers();
        mymodel.Students = GetStudents();
        return View(mymodel);
    }
}
C#
We can define our model as dynamic (not a strongly typed model) using the @model dynamic keyword.

View Code  

@using MultipleModelInOneView;
@model dynamic
@{
    ViewBag.Title = "Home Page";
}
<h2>@ViewBag.Message</h2>

<p><b>Teacher List</b></p>

<table>
    <tr>
        <th>Id</th>
        <th>Code</th>
        <th>Name</th>
    </tr>
    @foreach (Teacher teacher in Model.Teachers)
    {
        <tr>
            <td>@teacher.TeacherId</td>
            <td>@teacher.Code</td>
            <td>@teacher.Name</td>
        </tr>
    }
</table>

<p><b>Student List</b></p>

<table>
    <tr>
        <th>Id</th>
        <th>Code</th>
        <th>Name</th>
        <th>Enrollment No</th>
    </tr>
    @foreach (Student student in Model.Students)
    {
        <tr>
            <td>@student.StudentId</td>
            <td>@student.Code</td>
            <td>@student.Name</td>
            <td>@student.EnrollmentNo</td>
        </tr>
    }
</table>
JavaScript

2. Using View Model
ViewModel is nothing but a single class that may have multiple models. It contains multiple models as a property. It should not contain any method.

In the above example, we have the required View model with two properties. This ViewModel is passed to the view as a model. To get intellisense in the view, we need to define a strongly typed view.

public class ViewModel
{
    public IEnumerable<Teacher> Teachers { get; set; }
    public IEnumerable<Student> Students { get; set; }
}
C#
Controller code

public ActionResult IndexViewModel()
{
    ViewBag.Message = "Welcome to my demo!";
    ViewModel mymodel = new ViewModel();
    mymodel.Teachers = GetTeachers();
    mymodel.Students = GetStudents();
    return View(mymodel);
} 

@using MultipleModelInOneView;
@model ViewModel
@{
    ViewBag.Title = "Home Page";
}
<h2>@ViewBag.Message</h2>

<p><b>Teacher List</b></p>

<table>
    <tr>
        <th>Id</th>
        <th>Code</th>
        <th>Name</th>
    </tr>
    @foreach (Teacher teacher in Model.Teachers)
    {
        <tr>
            <td>@teacher.TeacherId</td>
            <td>@teacher.Code</td>
            <td>@teacher.Name</td>
        </tr>
    }
</table>

<p><b>Student List</b></p>

<table>
    <tr>
        <th>Id</th>
        <th>Code</th>
        <th>Name</th>
        <th>Enrollment No</th>
    </tr>
    @foreach (Student student in Model.Students)
    {
        <tr>
            <td>@student.StudentId</td>
            <td>@student.Code</td>
            <td>@student.Name</td>
            <td>@student.EnrollmentNo</td>
        </tr>
    }
</table>
JavaScript

3. Using ViewData
ViewData is used to transfer data from the controller to the view. ViewData is a dictionary object that may be accessible using a string as the key. Using ViewData, we can pass any object from the controller to the view. The Type Conversion code is required when enumerating in the view.

For the preceding example, we need to create ViewData to pass a list of teachers and students from the controller to the view.

Controller Code

public ActionResult IndexViewData()
{
    ViewBag.Message = "Welcome to my demo!";
    ViewData["Teachers"] = GetTeachers();
    ViewData["Students"] = GetStudents();
    return View();
}
C#
View Code

@using MultipleModelInOneView;
@{
    ViewBag.Title = "Home Page";
}
<h2>@ViewBag.Message</h2>
 <p><b>Teacher List</b></p>
@{

   IEnumerable<Teacher> teachers = ViewData["Teachers"] as IEnumerable<Teacher>;
   IEnumerable<Student> students = ViewData["Students"] as IEnumerable<Student>;
}
<table>
    <tr>
        <th>Id</th>
        <th>Code</th>
        <th>Name</th>
    </tr>
    @foreach (Teacher teacher in teachers)
    {
        <tr>
            <td>@teacher.TeacherId</td>
            <td>@teacher.Code</td>
            <td>@teacher.Name</td>
        </tr>
    }
</table>
 <p><b>Student List</b></p>
<table>
    <tr>
        <th>Id</th>
        <th>Code</th>
        <th>Name</th>
        <th>Enrollment No</th>
    </tr>
    @foreach (Student student in students)
    {
        <tr>
            <td>@student.StudentId</td>
            <td>@student.Code</td>
            <td>@student.Name</td>
            <td>@student.EnrollmentNo</td>
        </tr>
    }
</table>
JavaScript

4. Using ViewBag
ViewBag is similar to ViewData and is also used to transfer data from the controller to the view. ViewBag is a dynamic property. ViewBag is just a wrapper around the ViewData.

Controller Code 

public ActionResult IndexViewBag()
{
    ViewBag.Message = "Welcome to my demo!";
    ViewBag.Teachers = GetTeachers();
    ViewBag.Students = GetStudents();
    return View();
}
C#
View Code

@using MultipleModelInOneView;
@{
    ViewBag.Title = "Home Page";
}
<h2>@ViewBag.Message</h2>

<p><b>Teacher List</b></p>

<table>
    <tr>
        <th>Id</th>
        <th>Code</th>
        <th>Name</th>
    </tr>
    @foreach (Teacher teacher in ViewBag.Teachers)
    {
        <tr>
            <td>@teacher.TeacherId</td>
            <td>@teacher.Code</td>
            <td>@teacher.Name</td>
        </tr>
    }
</table>

<p><b>Student List</b></p>

<table>
    <tr>
        <th>Id</th>
        <th>Code</th>
        <th>Name</th>
        <th>Enrollment No</th>
    </tr>
    @foreach (Student student in ViewBag.Students)
    {
        <tr>
            <td>@student.StudentId</td>
            <td>@student.Code</td>
            <td>@student.Name</td>
            <td>@student.EnrollmentNo</td>
        </tr>
    }
</table>
JavaScript

5. Using Tuple
A Tuple object is an immutable, fixed-size and ordered sequence object. It is a data structure that has a specific number and sequence of elements. The .NET framework supports tuples up to seven elements.

Using this tuple object we can pass multiple models from the controller to the view.

Controller Code

public ActionResult IndexTuple()
{
    ViewBag.Message = "Welcome to my demo!";
    var tupleModel = new Tuple<List<Teacher>, List<Student>>(GetTeachers(), GetStudents());
    return View(tupleModel);
}
C#
View Code

@using MultipleModelInOneView;
@model Tuple <List<Teacher>, List <Student>>
@{
    ViewBag.Title = "Home Page";
}
<h2>@ViewBag.Message</h2>
<p><b>Teacher List</b></p>
<table>
    <tr>
        <th>Id</th>
        <th>Code</th>
        <th>Name</th>
    </tr>
    @foreach (Teacher teacher in Model.Item1)
    {
        <tr>
            <td>@teacher.TeacherId</td>
            <td>@teacher.Code</td>
            <td>@teacher.Name</td>
        </tr>
    }
</table>
<p><b>Student List</b></p>
<table>
    <tr>
        <th>Id</th>
        <th>Code</th>
        <th>Name</th>
        <th>Enrollment No</th>
    </tr>
    @foreach (Student student in Model.Item2)
    {
        <tr>
            <td>@student.StudentId</td>
            <td>@student.Code</td>
            <td>@student.Name</td>
            <td>@student.EnrollmentNo</td>
        </tr>
    }
</table>

----------------------------------
What is Kestrel?

Free open source,light weight,default web server which ships with asp.net core setup
Served by kestrel
default web server 
The Kestrel is the cross-platform web server for the ASP.NET Core application. That means this Server supports all the platforms and versions that the ASP.NET Core supports. By default, it is included as the internal web server in the .NET Core application.

HOW KESTREL WORKS :
The operating system receives an incoming HTTP request and sends it to Kestrel
Kestrel receives the request and performs initial parsing and processing, including URL routing and request header parsing.
Kestrel passes the request through the application’s middleware pipeline, which may include authorization, logging, and other custom logic.
The application generates a response and sends it back to Kestrel
Kestrel formats the response as an HTTP response and sends it back to the client.
Kestrel is designed to be fast and scalable, using asynchronous programming patterns and taking advantage of the low-level capabilities of the underlying operating system. It can handle high-performance workloads and can be configured to run behind a reverse proxy server for added security and scalability.

The Kestrel Web Server is generally used as an edge server i.e. the internet-facing web server which directly processes the incoming HTTP request from the client. In the case of the Kestrel web server, the process name that is used to host and run the ASP.NET Core application is the project name.
In the context of ASP.NET Core, Kestrel is a web server. It is a cross-platform, high-performance, and low-level web server for ASP.NET Core applications that is included as the default server in the .NET runtime. Kestrel is designed to handle high-performance, scalable web applications and can be used for both development and production environments. It can be run standalone or behind a reverse proxy server, such as IIS, Nginx, or Apache, to provide additional features such as SSL termination, load balancing, and caching.

Kestrel is a web server that runs directly on top of the operating system’s network stack and implements HTTP directly, without the use of additional software or libraries. When an ASP.NET Core application is started, Kestrel listens for incoming HTTP requests and processes them using the application’s middleware pipeline.

any request sent to mvc send to kestrel, it does all work

WHY DID MS not choose IIS?
INTERNET INFORMATION SERVER?

asp.net core is supposed to run cross platform but iis runs only on windows

DOES kestrel REPLACE IIS?
NO
IIS,APCHE,tomcat,nginx
cannot be public serving only mvc core
IN PRODUCTION reverse proxy architecture IIS and kestrel or another 2
in reverse proxy: first request comes to IIS/APACHE etc then forward to kestrel then it will forward to MVC then reverse the entire and kestrel is a mediator

with the OutOfProcess hosting model, there are 2 web servers i.e. one internal web server and one external web server. The internal web server is called Kestrel and the external web server can be IIS, Apache, or Nginx
As we already discussed ASP.NET Core is a cross-platform framework. It means it supports to development and run applications on different types of operating systems such as Windows, Linux, or Mac.

As of now, we are using visual studio to run the ASP.NET Core application. By default, the visual studio uses IIS Express to host and run the ASP.NET Core application. So, the process name is IIS Express that we already discussed in our previous article. 

Advantages of using Kestrel

Cross-platform: Kestrel is a cross-platform web server that runs on Windows, macOS, and Linux. This allows developers to write and deploy their applications on any operating system.

High performance: Kestrel is designed for high-performance, scalable web applications. It is implemented in a low-level, efficient manner and uses asynchronous programming patterns to handle high volumes of requests.
Lightweight: Kestrel is a lightweight and simple web server, making it easy to integrate with other components and systems. This allows for fast and flexible deployment of ASP.NET Core applications.
Flexible deployment: Kestrel can be run standalone or behind a reverse proxy server, such as IIS, Nginx, or Apache. This gives developers the flexibility to choose the best deployment configuration for their application, depending on their requirements.
Security: Kestrel supports secure connections using SSL/TLS, and it can be configured to run behind a reverse proxy server to provide additional security features, such as SSL termination, load balancing, and caching.
----------------------------------

ENTITY FRAMEWORK TYPES:

Code first: write all code i.e. the properties and the dbcontext , connection string andthen install ef nuget packages, sql server, eftools then use the migrations to create the database: 
enable-migrations; add-migration 'name'; update-database;
https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx

Very popular because hardcore programmers don't like any kind of designers and defining mapping in EDMX xml is too complex.
Full control over the code (no autogenerated code which is hard to modify).
General expectation is that you do not bother with DB. DB is just a storage with no logic. EF will handle creation and you don't want to know how it does the job.
Manual changes to database will be most probably lost because your code defines the database.

Database first:
Scaffold-DbContext [-Connection] [-Provider] [-OutputDir] [-Context] [-Schemas>] [-Tables>] 
                    [-DataAnnotations] [-Force] [-Project] [-StartupProject] [<CommonParameters>]
ex: PM> Scaffold-DbContext "Server=.\SQLExpress;Database=SchoolDB;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models
	
https://www.entityframeworktutorial.net/entityframework6/introduction.aspx	
					
for entire db just write the connection string without any table
Scaffold-DbContext "Server=LAPTOP-
4K7AS2ME\SQLEXPRESS;Database=Learn_DB;Truste
d_Connection=True;TrustServerCertificate=True;"
Microsoft.EntityFrameworkCore.SqlServer -
OutputDir Models

if just few tables:
Scaffold-DbContext "Server=LAPTOP-
4K7AS2ME\SQLEXPRESS;Database=Learn_DB:Truste
d_Connection=True;TrustServerCertificate=True;"
Microsoft.EntityFrameworkCore.SqlServer -
OutputDir Models -table tbl_customer,tbl_employee

if any column deleted dropped etc:

Scaffold-DbContext -connection name=constring
Microsoft.EntityFrameworkCore.SqlServer — OutputDir
Repos /Models -context dbfirstcontext -contextDir
Repos -DataAnnotations -f

Very popular if you have DB designed by DBAs, developed separately or if you have existing DB.
You will let EF create entities for you and after modification of mapping you will generate POCO entities.
If you want additional features in POCO entities you must either T4 modify template or use partial classes.
Manual changes to the database are possible because the database defines your domain model. You can always update model from database (this feature works quite well).
I often use this together VS Database projects (only Premium and Ultimate version).

Model first: add ado.net entity model: we define the edmx file in visual studio, empty and not linked to any db and then create all

IMHO popular if you are designer fan (= you don't like writing code or SQL).
You will "draw" your model and let workflow generate your database script and T4 template generate your POCO entities. You will lose part of the control on both your entities and database but for small easy projects you will be very productive.
If you want additional features in POCO entities you must either T4 modify template or use partial classes.
Manual changes to database will be most probably lost because your model defines the database. This works better if you have Database generation power pack installed. It will allow you updating database schema (instead of recreating) or updating database projects in VS.

What do you mean by lazy loading, eager loading and explicit loading?
Lazy Loading: This process delays the loading of related objects until they are needed. During lazy loading, only the objects needed by the user are returned, whereas all other related objects are only returned when needed.
Eager Loading: This process occurs when you query for an object and all of its related objects are returned as well. Aside from that, all related objects will load with the parent object automatically. When the Include method is used, eager loading can be achieved in EF6.
Explicit Loading: Explicit loading occurs only when lazy loading is desired, even when lazy loading is disabled. We must explicitly call the relevant load method on the related entities to process explicit loading. When the Load method is used, explicit loading can be achieved in EF6.

EF 1-3 ConceptualSchemaDL StorageSDL MappingSDL (edmx file req)
4.*-4.3 4.1 4.2 code first, lazy loading
ef 5-6 nuget packages
EF core 1.0 or ef7 
----------------------------------
Consuming api in .net core:
In order to Consume the Web API in this project, make sure your Web API project should be in running mode i.e. just press F5 key in Visual Studio to bring it to running mode
To call Web API I will be using a very popular HttpClient() class. To Deserialize JSON to Reservation object, Newtonsoft.Json package will be used.
using APIConsume.Models;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
 
namespace APIConsume.Controllers
{
    public class HomeController : Controller
    {
        public async Task<IActionResult> Index()
        {
            List<Reservation> reservationList = new List<Reservation>();
            using (var httpClient = new HttpClient())
            {
                using (var response = await httpClient.GetAsync("https://localhost:44324/api/Reservation"))
                {
                    string apiResponse = await response.Content.ReadAsStringAsync();
                    reservationList = JsonConvert.DeserializeObject<List<Reservation>>(apiResponse);
                }
            }
            return View(reservationList);
        }
    }
}

[HttpPost]
public async Task<IActionResult> GetReservation(int id)
{
    Reservation reservation = new Reservation();
    using (var httpClient = new HttpClient())
    {
        using (var response = await httpClient.GetAsync("https://localhost:44324/api/Reservation/" + id))
        {
            if (response.StatusCode == System.Net.HttpStatusCode.OK)
            {
                string apiResponse = await response.Content.ReadAsStringAsync();
                reservation = JsonConvert.DeserializeObject<Reservation>(apiResponse);
            }
            else
                ViewBag.StatusCode = response.StatusCode;
        }
    }
    return View(reservation);
}

[HttpPost]
        public async Task<IActionResult> AddReservation(Reservation reservation)
        {
            Reservation receivedReservation = new Reservation();
            using (var httpClient = new HttpClient())
            {
                StringContent content = new StringContent(JsonConvert.SerializeObject(reservation), Encoding.UTF8, "application/json");
 
                using (var response = await httpClient.PostAsync("https://localhost:44324/api/Reservation", content))
                {
                    string apiResponse = await response.Content.ReadAsStringAsync();
                    receivedReservation = JsonConvert.DeserializeObject<Reservation>(apiResponse);
                }
            }
            return View(receivedReservation);
        }
    }
----------------------------------
Calling sp store procedure in EF:

In modern development with Entity Framework Core (EF Core), it is recommended to use FromSqlRaw or LINQ for querying the database. The older methods like ExecuteStoreQuery and SqlQuery are not available in EF Core, and Entity Functions have been replaced with DbFunctions in EF Core.

NO LONGER THERE??: context.GetEmployeeData();  //entity function
NEW: context.Students.FromSql("GetStudents @p0","Bill").ToList(); //no insert updt
var albums = _dbContext.Album.FromSqlInterpolated < Album > ($ "SELECT AlbumId, Title, ArtistId FROM Album WHERE Title = {title}");
NEW: context.Database.ExecuteSqlCommand("CreateStudents @p0, @p1", parameters: new[] { "Bill", "Gates" }); //For the execution of SQL queries using plain strings, use ExecuteSqlRaw instead. For the execution of SQL queries using interpolated string syntax to create parameters, use ExecuteSqlInterpolated instead.
OLD:context.ExecuteStoreQuery<EmployeeDetails>("exec GetEmployeeData").ToList(); //4.0
OLD: context.Database.SqlQuery< EmployeeDetails >("exec GetEmployeeData", null).ToList();//4.1+
var affectedRows = context.Database.ExecuteSqlInterpolated($"UPDATE Students SET Age = Age + 1 WHERE Grade = {grade}");
context.Database.ExecuteSqlRaw("spInsertEmployee {0}, {1}, {2}, {3}", newEmployee.Name,newEmployee.Email,newEmployee.PhotoPath,newEmployee.Department);
NEW: context.Employees.FromSqlRaw<Employee>("SELECT * FROM Employees").ToList();
//FromSqlRaw to execute a SQL query or stored procedure that returns entities. ExecuteSqlRaw does not return entities

a. The first method of calling a stored procedure in Entity Framework is as an Entity Function. Entity Framework has the capability of importing a Stored Procedure as a function in your existing project/class. We can also map the result of the function back to any entity type or complex type in the project, Let's look at how we can do it. 
	Import Stored Procedure in Entity Framework, Right-click Stored Procedure and select "Add Function Import", Here, we can map a returned object of our Stored Procedure,
Now, we can call the Stored Procedure an entity function using the following code. The entity function returns a complex type called "EmployeeDetails".

using (Entities context = new Entities())
{
    IEnumerable<EmployeeDetails> empDetails = context.GetEmployeeData();
}

b. Call Stored Procedure using ExecuteStoreQuery<T> function

The method "T" can be anything, it may be an EF Generated entity or it may be a Custom Entity, so first I am creating a Custom Entity "EmployeeDetail". Here the EmployeeDetail properties name must be the same as the returned column of the select statement of the Stored Procedure.
public class EmployeeDetail
{
    public int EmployeeID { get; set; }
    public string EmployeeName { get; set; }
    public string DepartmentName { get; set; }
}

// using Object Context (EF4.0)
using (Entities context = new Entities())
{
        IEnumerable<EmployeeDetails> empDetails  =  context.ExecuteStoreQuery<EmployeeDetails>
                                                                                            ("exec GetEmployeeData").ToList();
}

// using DBContext (EF 4.1 and above)
using (Entities context = new Entities())
{
        IEnumerable<EmployeeDetails> empDetails  =  context.Database.SqlQuery
                                                                      < EmployeeDetails >("exec GetEmployeeData ", null).ToList();
}

c. DbDataReader:
using (Entities context = new Entities())
{
  string ConnectionString = (context.Connection as EntityConnection).StoreConnection.ConnectionString;
    SqlConnectionStringBuilder builder = new SqlConnectionStringBuilder(ConnectionString);
    builder.ConnectTimeout = 2500;
    SqlConnection con = new SqlConnection(builder.ConnectionString);
    System.Data.Common.DbDataReader sqlReader;
    con.Open();
    using (SqlCommand cmd = con.CreateCommand())
    {
        cmd.CommandText = "GetEmployeeData";
        cmd.CommandType = System.Data.CommandType.StoredProcedure;
        cmd.CommandTimeout = 0;

      sqlReader = (System.Data.Common.DbDataReader)cmd.ExecuteReader();
      IEnumerable<EmployeeDetail> empDetails = context.Translate<EmployeeDetail>(sqlReader).ToList();
    }
}

d. DbSet.FromSql():
Entity Framework Core provides the DbSet.FromSql() method to execute raw SQL queries for the underlying database and get the results as entity objects.

var context = new SchoolContext();

var students = context.Students
                  .FromSql("Select * from Students where Name = 'Bill'")
                  .ToList(); 

What is the difference between FromSql and ExecuteSqlCommand?
FromSql can only be used to execute raw SQL queries or stored procedures to get the data. You can't use it for INSERT/UPDATE/DELETE. If you want to execute INSERT, UPDATE, DELETE queries, use the ExecuteSqlCommand .

FromSqlInterpolated<>('sql'):
[HttpGet]
[Route("albums/{title}")]
public Album Get(string title) {
    var albums = _dbContext.Album.FromSqlInterpolated < Album > ($ "SELECT AlbumId, Title, ArtistId FROM Album WHERE Title = {title}");
    return albums.SingleOrDefault();
}
C#
And the generated SQL query is parameterized.

SELECT "a"."AlbumId", "a"."ArtistId", "a"."Title"
FROM (
    SELECT AlbumId, Title, ArtistId FROM Album WHERE Title = @p0
) AS "a"
				  
FromSqlRaw vs ExecuteSqlRaw
Use FromSqlRaw to execute a SQL query or stored procedure that returns entities. Use ExecuteSqlRaw to execute a SQL query or stored procedure that performs database operations but does not return entities. 

For example to execute a sql query or stored procedure that returns list of employees use FromSqlRaw 

public IEnumerable<Employee> GetAllEmployees()
{
    return context.Employees
                    .FromSqlRaw<Employee>("SELECT * FROM Employees")
                    .ToList();
}

Pass parameters to the query or stored procedure

public Employee GetEmployee(int id)
{
    return context.Employees
                    .FromSqlRaw<Employee>("spGetEmployeeById {0}", id)
                    .ToList()
                    .FirstOrDefault();
}

Use ExecuteSqlRaw to execute a SQL query or stored procedure that performs database operations but does not return entities. For example, if you want to execute insert, update or delete query or stored procedure use ExecuteSqlRaw method.

public Employee Add(Employee newEmployee)
{
    context.Database.ExecuteSqlRaw("spInsertEmployee {0}, {1}, {2}, {3}",
                                    newEmployee.Name,
                                    newEmployee.Email,
                                    newEmployee.PhotoPath,
                                    newEmployee.Department);
    return newEmployee;
}



sp in ef:

public partial class spGetStudents : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        var sp = @"CREATE PROCEDURE [dbo].[GetStudents]
                    @FirstName varchar(50)
                AS
                BEGIN
                    SET NOCOUNT ON;
                    select * from Students where FirstName like @FirstName +'%'
                END";

        migrationBuilder.Sql(sp);
    }

    protected override void Down(MigrationBuilder migrationBuilder)
    {

    }
}

Update-database

var context = new SchoolContext(); 

var students = context.Students.FromSql("GetStudents 'Bill'").ToList();

or

var name = "Bill";

var context = new SchoolContext(); 
var students = context.Students
                      .FromSql($"GetStudents {name}")
                      .ToList();

//or
//var students = context.Students.FromSql($"exec GetStudents {name}").ToList();

or 

var context = new SchoolContext(); 
var param = new SqlParameter("@FirstName", "Bill");

var students = context.Students.FromSql("GetStudents @FirstName", param).ToList();

or
var context = new SchoolContext(); 

var students = context.Students.FromSql("GetStudents @p0","Bill").ToList();
named parameter not supported in ef core

++++++
var context = new SchoolContext(); 

var rowsAffected = context.Database.ExecuteSqlCommand("Update Students set FirstName = 'Bill' where StudentId = 1;");

or

var context = new SchoolContext(); 

context.Students.FromSql("GetStudents @p0","Bill").ToList();
context.Database.ExecuteSqlCommand("CreateStudents @p0, @p1", parameters: new[] { "Bill", "Gates" });
context.ExecuteStoreQuery<EmployeeDetails>("exec GetEmployeeData").ToList(); //4.0
context.Database.SqlQuery< EmployeeDetails >("exec GetEmployeeData", null).ToList();//4.1+

----------------------------------
ADO.net to get data from sqlserver:
SqlConnection con = new SqlConnection(connectionString);
SqlCommand cmd = new SqlCommand("spGetAllStudent", con); 
SqlDataReader rdr = cmd.ExecuteReader(); 
while (rdr.Read())  { Convert.ToInt32(rdr["Id"]);

ExecuteNonQuery: This method is used to execute a command that does not return any result set, such as INSERT, UPDATE, DELETE, or DDL (Data Definition Language) statements.
SqlCommand command = new SqlCommand("UPDATE Students SET Age = Age + 1 WHERE Grade = 'A'", connection);
int rowsAffected = command.ExecuteNonQuery();
ExecuteScalar: This method is used to retrieve a single value (for example, an aggregate function result) from the database.
SqlCommand command = new SqlCommand("SELECT COUNT(*) FROM Students", connection);
int count = (int)command.ExecuteScalar();
ExecuteXmlReader: If your query returns XML data, you can use this method to obtain an XmlReader object for processing the XML results.
SqlCommand command = new SqlCommand("SELECT * FROM Students FOR XML AUTO", connection);
XmlReader reader = command.ExecuteXmlReader();
BeginExecuteNonQuery and EndExecuteNonQuery: These asynchronous methods are used for executing non-query commands asynchronously and retrieving the results later.
SqlCommand command = new SqlCommand("UPDATE Students SET Age = Age + 1 WHERE Grade = 'A'", connection);
IAsyncResult result = command.BeginExecuteNonQuery();
// ... Perform other operations
int rowsAffected = command.EndExecuteNonQuery(result);
BeginExecuteReader and EndExecuteReader: Similarly, these asynchronous methods are used for executing queries asynchronously and retrieving the results later.


string sqlText = @"UPDATE Customer
				  SET Name = @NewName, Age = @NewAge
				  WHERE ID = @RecordID";
  
SqlCommand dbCommand = new SqlCommand(sqlText, existingSqlConnection);

AddWithValue method:
dbCommand.Parameters.AddWithValue("@RecordID", CustomerID);
A more explicit format instantiates a new SqlParameter instance manually, adding it to the collection after its members have been set appropriately:
dbCommand.Parameters.Add(new SqlParameter("@RecordID", CustomerID));

public static class ConnectionString  
{  
   private static string cName = "Data Source=.; Initial Catalog=StudentManagement;User ID=sa;Password=123";  
   public static string CName { get => cName;}  
}  

[HttpPost]  
        [ValidateAntiForgeryToken]  
        public ActionResult Create(IFormCollection collection)  
        {  
            try  
            {  
                // TODO: Add insert logic here  
  
                return RedirectToAction(nameof(Index));  
            }  
            catch  
            {  
                return View();  
            }  
        } 
		
public class StudentDataAccessLayer  
    {          
      string connectionString = ConnectionString.CName;    
  
        public IEnumerable<Student> GetAllStudent()  
        {  
            List<Student> lstStudent = new List<Student>();  
            using (SqlConnection con = new SqlConnection(connectionString))  
            {  
                SqlCommand cmd = new SqlCommand("spGetAllStudent", con);  
                cmd.CommandType = CommandType.StoredProcedure;  
                con.Open();  
                SqlDataReader rdr = cmd.ExecuteReader();  
  
                while (rdr.Read())  
                {  
                    Student student = new Student();  
                    student.Id = Convert.ToInt32(rdr["Id"]);  
                    student.FirstName = rdr["FirstName"].ToString();  
                    student.LastName = rdr["LastName"].ToString();  
                    student.Email = rdr["Email"].ToString();  
                    student.Mobile = rdr["Mobile"].ToString();  
                    student.Address = rdr["Address"].ToString();  
  
                    lstStudent.Add(student);  
                }  
                con.Close();  
            }  
            return lstStudent;  
        }  
        public void AddStudent(Student student)  
        {  
            using (SqlConnection con = new SqlConnection(connectionString))  
            {  
                SqlCommand cmd = new SqlCommand("spAddStudent", con);  
                cmd.CommandType = CommandType.StoredProcedure;  
  
                cmd.Parameters.AddWithValue("@FirstName", student.FirstName);  
                cmd.Parameters.AddWithValue("@LastName", student.LastName);  
                cmd.Parameters.AddWithValue("@Email", student.Email);  
                cmd.Parameters.AddWithValue("@Mobile", student.Mobile);  
                cmd.Parameters.AddWithValue("@Address", student.Address);  
                con.Open();  
                cmd.ExecuteNonQuery();  
                con.Close();  
            }  
        }  
  
        public void UpdateStudent(Student student)  
        {  
            using (SqlConnection con = new SqlConnection(connectionString))  
            {  
                SqlCommand cmd = new SqlCommand("spUpdateStudent", con);  
                cmd.CommandType = CommandType.StoredProcedure;  
  
                cmd.Parameters.AddWithValue("@Id", student.Id);  
                cmd.Parameters.AddWithValue("@FirstName", student.FirstName);  
                cmd.Parameters.AddWithValue("@LastName", student.LastName);  
                cmd.Parameters.AddWithValue("@Email", student.Email);  
                cmd.Parameters.AddWithValue("@Mobile", student.Mobile);  
                cmd.Parameters.AddWithValue("@Address", student.Address);  
                con.Open();  
                cmd.ExecuteNonQuery();  
                con.Close();  
            }  
        }  
  
        public Student GetStudentData(int? id)  
        {  
            Student student = new Student();  
  
            using (SqlConnection con = new SqlConnection(connectionString))  
            {  
                string sqlQuery = "SELECT * FROM Student WHERE Id= " + id;  
                SqlCommand cmd = new SqlCommand(sqlQuery, con);  
                con.Open();  
                SqlDataReader rdr = cmd.ExecuteReader();  
  
                while (rdr.Read())  
                {  
                    student.Id = Convert.ToInt32(rdr["Id"]);  
                    student.FirstName = rdr["FirstName"].ToString();  
                    student.LastName = rdr["LastName"].ToString();  
                    student.Email = rdr["Email"].ToString();  
                    student.Mobile = rdr["Mobile"].ToString();  
                    student.Address = rdr["Address"].ToString();  
                }  
            }  
            return student;  
        }  
  
        public void DeleteStudent(int? id)  
        {  
            using (SqlConnection con = new SqlConnection(connectionString))  
            {  
                SqlCommand cmd = new SqlCommand("spDeleteStudent", con);  
                cmd.CommandType = CommandType.StoredProcedure;  
                cmd.Parameters.AddWithValue("@Id", id);  
                con.Open();  
                cmd.ExecuteNonQuery();  
                con.Close();  
            }  
        }  
----------------------------------
ADO vs Dapper:

Dapper and ADO.NET are both programming interfaces for accessing data in a database. Dapper is a lightweight, open-source micro-ORM for .NET that performs well for database operations. ADO.NET is a Microsoft Active-X component that gives developers a logical object model for accessing, editing, and updating data. 
Here are some ways Dapper and ADO.NET compare: 
Performance: Dapper is a good choice if performance is critical. ADO.NET is faster than Entity Framework.
Control: ADO.NET gives fine-grained control over database operations.
Features: EF Core provides a high-level API and many features.
Ease of use: Entity Framework allows you to work with data as strongly typed objects in C#.
Tooling: Dapper doesn't have much tooling and developer experience support.
Database changes: You have to manually update your queries and models if there are changes to the database tables.
Other ways Dapper and ADO.NET compare include: 
Query building: Both Dapper and Entity Framework provide methods to build parameterized queries.
SQL injection: Both Dapper and Entity Framework provide methods to pass sanitized parameters to stored procedures.
Stateless scenarios: Dapper is particularly good in stateless scenarios like the web.

ADO.NET
ADO.NET is a database access technology that is part of the .NET Framework. It provides a set of classes and interfaces that allow .NET applications to interact with databases. ADO.NET has been around for a long time and is widely used in .NET applications. ADO.NET is a low-level tool, which means that it provides fine-grained control over database operations.

However, this also means that developers have to write a lot of code to interact with databases. ADO.NET is widely used in .NET applications and has been around for a long time.

Let's see an example of how to use ADO.NET to retrieve data from a SQL Server database:

string connectionString = "Data Source=server;Initial Catalog=database;Integrated Security=True";
using (SqlConnection connection = new SqlConnection(connectionString))
{
    connection.Open();
    string query = "SELECT * FROM Customers WHERE Country = @Country";
    SqlCommand command = new SqlCommand(query, connection);
    command.Parameters.AddWithValue("@Country", "INDIA");
    SqlDataReader reader = command.ExecuteReader();
    while (reader.Read())
    {
        Console.WriteLine($"{reader["CustomerID"]}, {reader["CompanyName"]}, {reader["Country"]}");
    }
}
C#
Entity Framework Core
Entity Framework Core (EF Core) is a high-level ORM (Object-Relational Mapping) tool that allows .NET applications to interact with databases. It provides a set of classes and APIs that abstract the database operations, making it easier for developers to work with databases. EF Core is built on top of ADO.NET, which means it uses ADO.NET internally to interact with databases.

EF Core supports several database providers, including SQL Server, MySQL, SQLite, and PostgreSQL. It provides several features, such as automatic schema migration, query translation, and change tracking. EF Core also supports LINQ, which allows developers to write queries in C# instead of SQL.

Let's see an example of how to use EF Core to retrieve data from a SQL Server database:

string connectionString = "Data Source=server;Initial Catalog=database;Integrated Security=True";
using (var context = new MyDbContext(connectionString))
{
    var customers = context.Customers.Where(c => c.Country == "INDIA").ToList();
    foreach (var customer in customers)
    {
        Console.WriteLine($"{customer.CustomerID}, {customer.CompanyName}, {customer.Country}");
    }
}
C#
Dapper
Dapper is a micro ORM that was developed by the StackOverflow team. It provides a lightweight and fast way to work with databases. Dapper is built on top of ADO.NET and provides a simple API for database operations. Dapper is designed to be fast and efficient, which means that it doesn't have some of the features provided by EF Core.

Dapper is ideal for scenarios where performance is critical and developers want fine-grained control over the database operations. Dapper is also easy to learn and use, providing a small set of APIs covering most of the database operations.
Let's see an example of how to use Dapper to retrieve data from a SQL Server database:

string connectionString = "Data Source=server;Initial Catalog=database;Integrated Security=True";
using (var connection = new SqlConnection(connectionString))
{
    var customers = connection.Query<Customer>("SELECT * FROM Customers WHERE Country = @Country", new { Country = "INDIA" });
    foreach (var customer in customers)
    {
        Console.WriteLine($"{customer.CustomerID}, {customer.CompanyName}, {customer.Country}");
    }
}
C#
Comparison Entity Framework Core VS Dapper 
Now that we have examined the three tools let's compare them based on several factors.

Performance

When it comes to performance, Dapper is the clear winner. Dapper is designed to be fast and efficient and several times faster than EF Core and ADO.NET. EF Core is slower than Dapper because it has a lot of features, which means it has more overhead. ADO.NET is slower than Dapper because it is a low-level tool, which means that developers have to write a lot of code to interact with databases.

Ease of Use

Regarding ease of use, EF Core is the clear winner. EF Core provides a high-level API that abstracts the database operations, making it easier for developers to work with databases. EF Core also supports LINQ, which allows developers to write queries in C# instead of SQL. Dapper is also easy to use but requires developers to write SQL queries.

Features

When it comes to features, EF Core is the clear winner. EF Core provides a lot of features, such as automatic schema migration, query translation, and change tracking. Dapper doesn't provide all of these features, which means that developers have to implement them themselves. ADO.NET is a low-level tool and doesn't provide as many features as EF Core.

Flexibility

Dapper is the most flexible tool among the three because it allows developers to write SQL queries and map the results to any class or structure. EF Core is less flexible than Dapper because it requires developers to define classes that map to database tables. ADO.NET is also less flexible than Dapper because it requires developers to write more code to map the results to classes or structures.

Which Tool Should We Use?
The choice of tool depends on the requirements of your project. If you need a lightweight and fast tool for database operations, Dapper is a good choice. If you need a tool that provides a high-level API and many features, EF Core is a good choice. If you need fine-grained control over database operations, ADO.NET is a good choice.
----------------------------------
Bulk Copy in .net mvc://SqlBulkCopy objbulk = new SqlBulkCopy(con);objbulk.DestinationTableName = "tblTest";  objbulk.ColumnMappings.Add("ID", "ID"); con.Open();objbulk.WriteToServer(dt);con.Close();

ob.DestinationTableName=
ob.ColumnMappings.Add(id,id)
ob.WriteToServer(dt); con.close();

Inserting multiple records in a database is the most common and important task in almost all application. There are inbuilt classes in .NET which support bulk insert which helps to insert multiple records in Database. 

First of all, we need to create DataTable which has identical column names and in the same sequence. 
DataTable tbl = new DataTable();  
tbl.Columns.Add(new DataColumn("ID", typeof(Int32)));   
tbl.Columns.Add(new DataColumn("isDeleted", typeof(bool)));  
tbl.Columns.Add(new DataColumn("Manual", typeof(string)));  
tbl.Columns.Add(new DataColumn("source", typeof(string)));  
Note that we need the same Database Table and in the same sequence which is in datatable.
 
After that, fill the datatable with data. Here, I am inserting dummy data of 10000 records.
for(int i=0; i<10000; i++)  
{   DataRow dr = tbl.NewRow();  
     dr["ID"] = i;   
     dr["isDeleted"] = DBNull.Value;  
     dr["Manual"] = DBNull.Value;  
     dr["source"] = "Test";  
    tbl.Rows.Add(dr);}   
Now, you are ready with the data of 10000 records which we need to insert. For that, follow the below steps.
string connection = "Data Source=192.168.1.1;Initial Catalog=XXXXXXX;User Id = abc123; Password = xxxxxxxx";  
SqlConnection con = new SqlConnection(connection);  
//create object of SqlBulkCopy which help to insert  
SqlBulkCopy objbulk = new SqlBulkCopy(con);  
   
//assign Destination table name  
objbulk.DestinationTableName = "tblTest";  
Now, the most important task is of MAPPING the columns of Datatable to Database Table. We need to MAP each column as below,
objbulk.ColumnMappings.Add("ID", "ID");   
objbulk.ColumnMappings.Add("isDeleted", "isDeleted");  
objbulk.ColumnMappings.Add("Manual", "Manual");  
objbulk.ColumnMappings.Add("source", "source");  
    
con.Open();  
//insert bulk Records into DataBase.  
objbulk.WriteToServer(dt);  
con.Close();  
Common Errors
"The given ColumnMapping does not match up with any column in the source or destination. "

Solution
Check the database table names case sensitive. Also, check the sequence of the column.

There is another common and confusing error "Error-the given value of type String from the data source cannot be converted to type nvarchar of the specified target column." 

Solution 
Don't worry, please check the Length of the Column, if the length of data is bigger than column length, it will give this conversion error. increase the length of the column and you will be good.

////
alternative:
private void WriteToDatabase()
{
    // get your connection string
    string connString = "";
    // connect to SQL
    using (SqlConnection connection = 
            new SqlConnection(connString))
    {
        // make sure to enable triggers
        // more on triggers in next post
        SqlBulkCopy bulkCopy = 
            new SqlBulkCopy
            (
            connection, 
            SqlBulkCopyOptions.TableLock | 
            SqlBulkCopyOptions.FireTriggers | 
            SqlBulkCopyOptions.UseInternalTransaction,
            null
            );

        // set the destination table name
        bulkCopy.DestinationTableName = this.tableName;
        connection.Open();

        // write the data in the "dataTable"
        bulkCopy.WriteToServer(dataTable);
        connection.Close();
    }
    // reset
    this.dataTable.Clear();
    this.recordCount = 0;
}

----------------------------------
Adding response headers:
app.Use(async (context, nextMiddleware) =>
{
    context.Response.OnStarting(() =>
    {
        context.Response.Headers.Add("Site", "Simple-Talk");
        return Task.FromResult(0);
    });
    await nextMiddleware();
});

Basic HTTP Header Extraction
Manipulating with HTTP headers in ASP.NET Core is easy enough to do as part of an execution that has access to the Request.Headers dictionary.

In ASP.NET Core, the IHeaderDictionary is the interface that defines the HTTP request headers. These headers comprise a key-value pairs dictionary. The header keys are strings and the header values are StringValues structs:

[HttpGet("from-basic")] 
public IActionResult ExtractFromBasic() 
{ 
   const string HeaderKeyName = "HeaderKey"; 
   Request.Headers.TryGetValue(HeaderKeyName, out StringValues headerValue); 
   return Ok(headerValue); 
}

Attribute HTTP Header Extraction
ASP.NET Core introduces the FromHeader attributes: 

Wanna join Code Maze Team, help us produce more awesome .NET/C# content and get paid? >> JOIN US! <<
[HttpGet("from-header-attribute")]
public IActionResult ExtractFromQueryAttribute([FromHeader] HeaderDTO headerDTO)
{
    return Ok(headerDTO);
}

We use the FromHeader attribute to specify that a parameter or property should be bound using the request headers.

Of course, for this to work, we need the HeaderDTO class:

public class HeaderDTO
{
    [FromHeader]
    public string FirstName { get; set; } = string.Empty;
    [FromHeader]
    public string LastName { get; set; } = string.Empty;
}

Custom Header Extraction Using Action Filter
If we want to ensure the extraction of any custom header in any endpoint in our ASP.NET Core Web API,  we can use ASP.NET Core action filters.

An action filter is another possibility that we have to extract a custom header value before an action is invoked:

public class ExtractCustomHeaderAttribute : ActionFilterAttribute
{
   public override void OnActionExecuting(ActionExecutingContext context)
   {
      const string HeaderKeyName = "FilterHeaderKey";
      context.HttpContext.Request.Headers.TryGetValue(HeaderKeyName, out StringValues headerValue);
      if (context.HttpContext.Items.ContainsKey(HeaderKeyName))
      {
         context.HttpContext.Items[HeaderKeyName] = headerValue;
      }
      else
      {
         context.HttpContext.Items.Add(HeaderKeyName, $"{headerValue}-received");
      }
   }
}
----------------------------------
HOW TO WORK WITH JSON in project:
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
app.UseSession();
}
++++++
public void ConfigureServices(IServiceCollection services)
{
  //Added for session state
  services.AddDistributedMemoryCache();
   
  services.AddSession(options =>
  {
  options.IdleTimeout = TimeSpan.FromMinutes(10);               
  });
}
++++++
public class EmployeeDetails
{
    public string EmployeeId { get; set; }
    public string DesignationId { get; set; }
}
++++++
public static class SessionExtensions
{
  public static void SetObjectAsJson(this ISession session, string key, object value)
   {
     session.SetString(key, JsonConvert.SerializeObject(value)); //http.text.json: JsonSerializer.SerializeObject()
   }
    
   public static T GetObjectFromJson<T>(this ISession session, string key)
   {
     var value = session.GetString(key);
     return value == null ? default(T) : JsonConvert.DeserializeObject<T>(value);
   }
}
++++++
var employee = new EmployeeDetails();
employee.EmployeeId = "1";
employee.DesignationId = "2";

HttpContext.Session.SetObjectAsJson("EmployeeDetails", employee);
To retrieve your complex object in your session:

var employeeDetails = HttpContext.Session.GetObjectFromJson<EmployeeDetails>("EmployeeDetails");
int employeeID = Convert.ToInt32(employeeDetails.EmployeeId);
int designationID= Convert.ToInt32(employeeDetails.DesignationId);


also:
@using Microsoft.AspNetCore.Http
@inject IHttpContextAccessor HttpContextAccessor
@{
    //Get object from session
    var mySessionObject = HttpContextAccessor.HttpContext.Session.GetObjectFromJson<EmployeeDetails>("EmployeeDetails");
 }

<h1>@mySessionObject.EmployeeId</h1>
<h1>@mySessionObject.DesignationId</h1>
----------------------------------
CSRF vs SOP vs CORS vs CSP:
+++++++++
SOP (Same Origin Policy)—is an important concept in the web application security model. The source combines the scheme (protocol), hostname, and port.
+++++++++
CSRF:
CSRF (Cross-Site Request Forgery) is a web attack that exploits loopholes in the SOP policy, and CORS does not block them. The attack consists of the attacker running malicious scripts in the victim's browser, and thus the victim performs unintended actions on his behalf.
CSRF attack will work if application authorization is based on cookies. The attack uses the knowledge that if the user has cookies for the domain, the browser will automatically add them to the request.
To protect your web application against such attacks, always,
Use unpredictable parameters. Make it difficult for an attacker to simulate or construct a request to your application. An example of unpredictable parameters of the use of tokens, which are going to be explained soon.
Strictly validate in every case and in every step.
An anti-forgery token, also called CSRF token, is a unique, secret, unpredictable parameter generated by a server-side application for a subsequent HTTP request made by the client. When that request is made, the server validates this parameter against the expected value and rejects the request if the token is missing or invalid.
So, basically, the following request,
GET http://bank.com/transfer?amount=1000&to=12345  
Will be extended with a third argument:
GET http://bank.com/transfer?amount=1000&to=12345&token=32465468465468465165484654768732467655465  
That token is huge and impossible-to-guess. The server will include that token for the subsequent request only and will generate a new one each time a page/form is served

Token Generation: The Manual Way
 
There are two ways to generate and validate anti-forgery tokens, we will start by the manual, uncomfortable way. This can be done by using the IAntiForgery service.
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Csrf  
@functions {  
  public string GenerateCsrfToken()  
  {  
    return Csrf.GetAndStoreTokens(Context).RequestToken;  
  }  
}  
<form method="post">  
  <input type="hidden" id="RequestVerificationToken" name="RequestVerificationToken" value="@GenerateCsrfToken()" />  
</form>   
The GetAndStoreTokens method generates a request token and stores the token in a response cookie. You get access to the generated token using the RequestToken property.
 
The generated hidden field will be like the following (the token has been abbreviated for clarity), 
<input type="hidden" id="RequestVerificationToken" name="RequestVerificationToken" value="CfDJ8El14QZHDe5Dtl0m3qOu6_PbEHcKAJ5ZjSRj6iF...">  

Another, clearer way, for manually generating CSRF tokens is by using the MVC HTML helper,
<form method="post">  
  @Html.AntiForgeryToken()  
</form>  

Token Generation: The Automatic Way
As we said earlier, the new ASP.NET Core Razor engine will always generate CSRF tokens for you, however, you still have the control over the token generation process.
You can customize the token generation process for Razor pages using the AddAntiforgery method which can be called in your Startup.ConfigureServices method.
services.AddAntiforgery(options =>  
{  
  options.FormFieldName = "AntiForgeryFieldName";  
  options.HeaderName = "AntiForgeryHeaderName";  
  options.Cookie.Name = "AntiForgeryCookieName";  
});  
The previous code will generate a hidden field for the token with the specified name, and the token will be sent along with the request with the specified header name.
<input name="AntiForgeryFieldName" type="hidden" value="CfDJ8N1DZWaKEuhDio...">  
By default, the generated cookie name in ASP.NET core is “.AspNetCore.Antiforgery.<hash>”, the field name is “__RequestVerificationToken”, and the header name is “RequestVerificationToken”.

Token Validation
 
Now comes the next step, the token validation. Let us start by the normal, uncomfortable way. In your target action, you may use the following code for token validation:
private Microsoft.AspNetCore.Antiforgery.IAntiforgery Csrf { get; set; }  
public ApiController(Microsoft.AspNetCore.Antiforgery.IAntiforgery csrf)  
{  
  this.Csrf = csrf;  
}  
  
private async Task<bool> ValidateAntiForgeryToken()  
{  
  try  
  {  
    await Csrf.ValidateRequestAsync(this.HttpContext);  
    return true;  
  }  
  catch (Microsoft.AspNetCore.Antiforgery.AntiforgeryValidationException)  
  {  
    return false;  
  }  
}  
  
  
[HttpPost]  
public async Task<ActionResult<int>> Debit(int amount)  
{  
  if (false == await ValidateAntiForgeryToken())  
    return BadRequest();  
  
  // action logic here  
}   

Token Validation
 
Now comes the next step, the token validation. Let us start by the normal, uncomfortable way. In your target action, you may use the following code for token validation:
private Microsoft.AspNetCore.Antiforgery.IAntiforgery Csrf { get; set; }  
public ApiController(Microsoft.AspNetCore.Antiforgery.IAntiforgery csrf)  
{  
  this.Csrf = csrf;  
}  
  
private async Task<bool> ValidateAntiForgeryToken()  
{  
  try  
  {  
    await Csrf.ValidateRequestAsync(this.HttpContext);  
    return true;  
  }  
  catch (Microsoft.AspNetCore.Antiforgery.AntiforgeryValidationException)  
  {  
    return false;  
  }  
}  
  
  
[HttpPost]  
public async Task<ActionResult<int>> Debit(int amount)  
{  
  if (false == await ValidateAntiForgeryToken())  
    return BadRequest();  
  
  // action logic here  
}   

Worth mentioning that ValidateAntiForgeryToken can be applied to the controller class and will cause CSRF validation on all endpoints. We also have some alternatives to using ValidateAntiForgeryToken attribute,
AutoValidateAntiForgeryToken attribute: Will automatically validate endpoints for all HTTP methods except GET, HEAD, OPTIONS and TRACE.
IgnoreAntiforgeryToken attribute: Will ignore a method from validation if the parent class is decorated with ValidateantiForgeriyToken or AutoValidateAntiForgeryToken

Anti-Forgery in Angular
 
Normally, when accessing a CSRF-protected endpoint from an Angular app, you will receive 400 bad request if you did not specify the CSRF header.
 

 
To handle this, you must know the following,
Angular will recognize a CSRF token only if it is stored as a cookie under Angular’s dedicated name, which is “XSRF-TOKEN”.
Angular will always send the cookie token as a header under the dedicated name “X-XSRF-TOKEN”.
Your app must be able to generate the CSRF cookie under Angular’s dedicated name and to validate the CSRF header also under Angular’s dedicated name.
Let us see how we do this,
public void Configure(IApplicationBuilder app, IWebHostEnvironment env, IAntiforgery antiforgery)  
{  
  app.Use((context, next) =>  
  {  
    // return current accessed path  
    string path = context.Request.Path.Value;  
  
    if (path.IndexOf("/api/", StringComparison.OrdinalIgnoreCase) != -1)  
    {  
      var tokens = antiforgery.GetAndStoreTokens(context);  
      context.Response.Cookies.Append("XSRF-TOKEN", tokens.RequestToken,  
        new CookieOptions() { HttpOnly = false });  
    }  
  
    return next();  
  });  
}  
services.AddAntiforgery(opts =>  
{  
  opts.HeaderName = "X-XSRF-TOKEN";  
}); 

+++++++++++++++++++++++++
ValidateAntiForgeryToken:
The basic purpose of ValidateAntiForgeryToken attribute is to prevent cross-site request forgery attacks.

A cross-site request forgery is an attack in which a harmful script element, malicious command, or code is sent from the browser of a trusted user. For more information on this please visit http://www.asp.net/mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages.

It is simple to use, you need to decorate method with ValidateAntiForgeryToken attribute as below:

[HttpPost]  
[ValidateAntiForgeryToken]  
public ActionResult CreateProduct(Product product)  
{
  if (ModelState.IsValid)  
  {
    //your logic 
  }
  return View(ModelName);
}
It is derived from System.Web.Mvc namespace.

And in your view, add this code to add the token so it is used to validate the form upon submission.

@Html.AntiForgeryToken()

It will generate input element for your form similar to this:

<input name="__RequestVerificationToken" type="hidden" 
       value="CfDJ8HSQ_cdnkvBPo-jales205VCq9ISkg9BilG0VXAiNm3Fl5Lyu_JGpQDA4_CLNvty28w43AL8zjeR86fNALdsR3queTfAogif9ut-Zd-fwo8SAYuT0wmZ5eZUYClvpLfYm4LLIVy6VllbD54UxJ8W6FA">
	   

////Header.Set("X-CSFR-TOKEN")
+++++++++
CSP: content security policy:

A Content Protection Policy (CSP) is a security standard that provides an additional layer of protection from cross-site scripting (XSS), clickjacking, and other code injection attacks. It is a defensive measure against any attacks that rely on executing malicious content in a trusted web context, or other attempts to circumvent the same-origin policy.

With CSP, you can limit which data sources are allowed by a web application, by defining the appropriate CSP directive in the HTTP response header

app.Use(async (context, next) => {
    context.Response.Headers.Add("Content-Security-Policy", "default-src 'self'; script-src 'self'; style-src 'self'; font-src 'self'; img-src 'self'; frame-src 'self'");

    await next();
});

++++++++++
Allow CORS:

Cross-origin resource sharing is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served. A web page may freely embed cross-origin images, stylesheets, scripts, iframes, and videos

builder.Services.AddCors(options =>
{
	options.AddDefaultPolicy(policy =>
    {
    	policy.WithOrigins("http://localhost:4200") // or AllowAnyOrigin()
        .AllowAnyHeader()
        .AllowAnyMethod()
        .AllowAnyOrigin();
    })
});

var MyAllowSpecificOrigins = "_myAllowSpecificOrigins"
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddCors(options => { options.AddPolicy(MyAllowSpecificOrigins, policy => { policy.WithOrigins("http://example.com", "http://www.contoso.com") .AllowAnyHeader() .AllowAnyMethod(); }); });

----------------------------------
CLEAN architecture(SEE):
Clean architecture is a software design philosophy that separates the elements of a design into ring levels. An important goal of clean architecture is to provide developers with a way to organize code in such a way that it {encapsulates the business logic} but keeps it (separate from the delivery mechanism).

Layer 1: domain layer: all the business entities and business rules should be here. 
Domain and Application layer(Application business rule) at the center.

Layer 2: interface adapters layer: here are the controllers, interfaces, APIs, connectors, gateways.

Layer 3: infrastructure and presentation layer: all the low-level technical implementations should live here: frameworks, libraries, databases, ui user interfaces, external interfaces and APIs, infrastructure, web, device, external libraries, I/O.
SEE 
https://www.c-sharpcorner.com/article/clean-architecture-in-asp-net-core-web-api/

https://www.freecodecamp.org/news/a-quick-introduction-to-clean-architecture-990c014448d2/

https://codilime.com/blog/clean-architecture/#:~:text=Clean%20architecture%20is%20a%20set,of%20layers%20in%20some%20cases.
----------------------------------
CQRS Pattern:

The Command and Query Responsibility Segregation (CQRS) pattern states that we must separate the operations for reading the data from the operations for writing or updating the data. This means that functions for reading and writing data are not kept in the same interface or class
Separate teams can work on these operations
Each can be made to scale according to their own needs. Write operations are mostly used much less than read operations
Each can have their own security as per requirements
Read operations can have a different architecture to support caching, conversions to data transformation objects as required by clients
Write operations can include data validation. lookups etc.

However, do keep in mind that this pattern is better suited to larger applications where the requirements and load levels between read and write operations are different. For a simple and small application, the normal CRUD pattern, often auto-generated from ORM tools, is sufficient.

We will now look at a simple implementation of the CQRS pattern in a C# .NET console application. This application will have two repositories. One for the read operations, although we will only have one operation for demo purposes and another for write operations. These repositories will be called by the respective middle-tier components. As the repositories, there will be one for queries (reads) and another for Commands (writes)

Let's first look at the two repositories (These are in the repositories folder)

The Commands (Write) repository

using ConsoleAppCQRSPattern.Models;
namespace ConsoleAppCQRSPattern.Repositories {
    public interface IEmployeeCommandsRepository {
        void SaveEmployee(Employee employee);
    }
}
using ConsoleApp CQRSPattern.Models;
namespace ConsoleApp CQRSPattern.Repositories {
    public class EmployeeCommandsRepository: IEmployeeCommandsRepository {
        public void SaveEmployee(Employee employee) {
            // Persist the employee record in a data store
        }
    }
}
C#
Here we see that only write operations (in this case only one) are included.

The Queries (Read) repository

using ConsoleAppCQRSPattern.Models;
namespace ConsoleAppCQRSPattern.Repositories {
    public interface IEmployeeQueriesRepository {
        Employee GetByID(int employeeID);
    }
}
using System;
using ConsoleAppCQRSPattern.Models;
namespace ConsoleAppCQRSPattern.Repositories {
    public class EmployeeQueriesRepository: IEmployeeQueriesRepository {
        public Employee GetByID(int employeeID) {
            // Get the employee record from a data store
            // Below is for demo purposes only
            return new Employee() {
                Id = 100,
                    FirstName = "John",
                    LastName = "Smith",
                    DateOfBirth = new DateTime(2000, 1, 1),
                    Street = "100 Toronto Street",
                    City = "Toronto",
                    PostalCode = "k1k 1k1"
            };
        }
    }
}
C#
Here we see that only read operations (in this case only one) are included.

Next, we look at the two middle-tier components (These are in the Queries and Commands folders),

Queries (To read data)

using ConsoleAppCQRSPattern.DTOs;
namespace ConsoleAppCQRSPattern.Queries {
    public interface IEmployeeQueries {
        EmployeeDTO FindByID(int employeeID);
    }
}
using System;
using ConsoleAppCQRSPattern.Repositories;
using ConsoleAppCQRSPattern.DTOs;
namespace ConsoleAppCQRSPattern.Queries {
    public class EmployeeQueries {
        private readonly IEmployeeQueriesRepository _repository;
        public EmployeeQueries(IEmployeeQueriesRepository repository) {
            _repository = repository;
        }
        public EmployeeDTO FindByID(int employeeID) {
            var emp = _repository.GetByID(employeeID);
            return new EmployeeDTO {
                Id = emp.Id,
                    FullName = emp.FirstName + " " + emp.LastName,
                    Address = emp.Street + " " + emp.City + " " + emp.PostalCode,
                    Age = Convert.ToInt32(Math.Abs(((DateTime.Now - emp.DateOfBirth).TotalDays) / 365)) - 1
            };
        }
    }
}
C#
Commands (To write data)

using ConsoleAppCQRSPattern.Models;
namespace ConsoleAppCQRSPattern.Commands {
    public interface IEmployeeCommands {
        void SaveEmployeeData(Employee employee);
    }
}
using ConsoleAppCQRSPattern.Models;
using ConsoleAppCQRSPattern.Repositories;
namespace ConsoleAppCQRSPattern.Commands {
    public class EmployeeCommands: IEmployeeCommands {
        private readonly IEmployeeCommandsRepository _repository;
        public EmployeeCommands(IEmployeeCommandsRepository repository) {
            _repository = repository;
        }
        public void SaveEmployeeData(Employee employee) {
            _repository.SaveEmployee(employee);
        }
    }
}
C#
Here we see that we have separate operation handling components. Two other classes are the main Employee class which mirrors our storage item and the Employee DTO class which is used by the Queries (Read) operations to return data in a shape required by the consuming client.

namespace ConsoleAppCQRSPattern.DTOs {
    public class EmployeeDTO {
        public int Id {
            get;
            set;
        }
        public string FullName {
            get;
            set;
        }
        public int Age {
            get;
            set;
        }
        public string Address {
            get;
            set;
        }
    }
}
using System;
namespace ConsoleAppCQRSPattern.Models {
    public class Employee {
        public int Id {
            get;
            set;
        }
        public string FirstName {
            get;
            set;
        }
        public string LastName {
            get;
            set;
        }
        public DateTime DateOfBirth {
            get;
            set;
        }
        public string Street {
            get;
            set;
        }
        public string City {
            get;
            set;
        }
        public string PostalCode {
            get;
            set;
        }
    }
}
C#
Finally, we call these operations from the main Program class. Please note that in this demo application, we create an instance of the repository directly. In a real-world scenario, we would probably use some dependency injection framework to do this.

using ConsoleAppCQRSPattern.Commands;
using ConsoleAppCQRSPattern.Queries;
using ConsoleAppCQRSPattern.Repositories;
using System;
namespace ConsoleAppCQRSPattern {
    classProgram {
        staticvoid Main(string[] args) {
            // Command the Employee Domain to save data
            var employeeCommand = new EmployeeCommands(new EmployeeCommandsRepository());
            employeeCommand.SaveEmployeeData(new Models.Employee {
                Id = 200, FirstName = "Jane", LastName = "Smith", Street = "150 Toronto Street", City = "Toronto", PostalCode = "j1j1j1", DateOfBirth = new DateTime(2002, 2, 2)
            });
            Console.WriteLine($ "Employee data stored");
            // Query the Employee Domain to get data
            var employeeQuery = new EmployeeQueries(new EmployeeQueriesRepository());
            var employee = employeeQuery.FindByID(100);
            Console.WriteLine($ "Employee ID:{employee.Id}, Name:{employee.FullName}, Address:{employee.Address}, Age:{employee.Age}");
            Console.ReadKey();
        }
    }
}
----------------------------------
Response Caching:
Response caching means storing response output. Browsers and other clients use response caching to cache a server's response in order to retrieve it quickly and efficiently in response to subsequent requests. In ASP.NET Core, response caching reduces server load and improves user experience in web applications. The purpose of this blog is to provide a detailed explanation of response caching in ASP.NET Core.

What is Response Caching?
Using the response cache, the server can store responses in memory or on disk so that they can be retrieved quickly for subsequent requests. Caching mechanisms check the cache for responses whenever a request is made to the server. Rather than generating a new response, the cache returns the response. Using response caching reduces some server workload and reduces some requests to the server.

Note. HTTP caching directives and how we can control caching behavior using them
Response Caching Headers
The 'Client and Server' exchange HTTP header information to cache the response. HTTP caching directives and how we can control caching behavior using them. Cache control specifies how the response can be cached. It is the responsibility of browsers, clients, and proxy servers to honor the cache-control header when it is present in the response.

Main Response Caching Headers are like below,

Cache-Control
Pragma
Vary
Cache-Control Header

The Cache-Control header is the main header type for response caching. To add a Cache-Control header in ASP.Net Core, you can use the Response object in your controller's action method. So, Let's Start with the common cache-control directives:

public: this cache can store the response either on the client side or at a shared location.
private: This Private Cache always stores Client Side Response But does Not Shred the Cache From The Client Side.
max-age: this cache-control header represents a time to hold a response in the cache.
no-cache: this value indicates that the client should not cache the response.
no-store: this cache must not store the response.

Pragma Header
For ASP.NET Core, the Pragma header can control cache performance. Server and client instructions are included in the Pragma header. Pragma is skipped if the response is decorated with Cache-Control.

Vary Header
The Vary http response header is part of the request message from this method, and the URL is the content of the response.

ResponseCache Attribute
ResponseCache attributes define header all properties for response cache headers in the ASP.NET Core web app. This attribute can be applied at the controller level or each endpoint.

Below, you will find a few input parameters for the cache attribute.

Duration
You can set or retrieve the response's cached duration in seconds. This defines "max-age" in the "cache-control" header. The max-age header, which is used to specify the cache duration, will be produced by this property's duration.

Location
sets the Location wherever the data from a particular URL should be cached. If the Location is decorated with "ResponseCacheLocation.Client," it works as a cached response in the client and sets "cache-control" to the private header.

In this example, the Location is decorated with "ResponseCacheLocation.None" operates as "cache-control," and the "Pragma" header is set to "no-cache".

Note. If you can check the cache response, then click the links on web pages or use Swagger to run API endpoints in the browser. 

Otherwise, if you try to refresh the page or revisit the URI page, the browser will always request a new response from the server side, regardless of the response cache settings.

Public
​public class HomeController: Controller
{
    [HttpGet]
    [ResponseCache(Duration = 180, Location = ResponseCacheLocation.Any)]
    public IActionResult getCache()
    {
        return Ok($"Responses are generated on {DateTime.Now}");
    }
}
C#
This Duration property will generate the max-age header, which we use to define the duration of the cache for 3 minutes (180 seconds). The Location property will define the Location within the cache-control header.

So, the API endpoint and verify these response headers:

cache-control: public,max-age=180

​The status code indicates that the response comes from the disk cache:

Status Code: 200

Private
We just need to change the Location property in ResponseCacheLocation.Client to private:

​public class HomeController: Controller
{
    [HttpGet]
    [ResponseCache(Duration = 180, Location = ResponseCacheLocation.Client)]
    public IActionResult getCache()
    {
        return Ok($"Responses are generated on {DateTime.Now}");
    }
}
C#
This changes the value of the cache control header to private, which means that only the client can cache the response:

cache-control: private,max-age=180

No-Cache
Now let us update the Location parameter to ResponseCacheLocation.  None:

public class HomeController: Controller
{
    [HttpGet]
    [ResponseCache(Duration = 180, Location = ResponseCacheLocation.None)]
    public IActionResult getCache()
    {
        return Ok($"Responses are generated on {DateTime.Now}");
    }
}
C#
Because the cache-control and pragma headers are set to no-cache, the client is unable to use a cached response without first verifying it with the server:

cache-control: no-cache,max-age=180

pragma: no-cache

The server generates a new response each time, and the browser does not use the cached response.

NoStore 
Gets or sets the value to determine whether to store the data. If NoStore is decorated with the value "true", the "cache-control" header is set to "no-store". It ignores the "Location" and the parameter has ignored the values; otherwise values "None".

​public class HomeController: Controller
{
    [HttpGet]
    [ResponseCache(Duration = 180, Location = ResponseCacheLocation.Any,NoStore =True)]
    public IActionResult getCache()
    {
        return Ok($"Responses are generated on {DateTime.Now}");
    }
}
C#
This sets the response header cache control to no-store. This means that the client should not cache the response:

cache-control: no-store

VaryByHeader
Sets or gets the "Vary" response header value. ResponseCache's VaryByHeader property allows us to set the vary header:

Now that User-Agent is the value for the VaryByHeader property, the cached response will be used as long as the request originates from the same client device. Once the User-Agent value on the client device changes, a new response will be fetched from the server. Let's verify this.

​public class HomeController: Controller
{
    [HttpGet]
    [ResponseCache(Duration = 180, Location = ResponseCacheLocation.Any,VaryByHeader="User-Agent")]
    public IActionResult getCache()
    {
        return Ok($"Responses are generated on {DateTime.Now}");
    }
}
C#
In the response headers, check for the Vary header:

vary: User-Agent

Cache Profile
In this project, you can use Response Cache attributes, as most action methods have the same input parameters. With ASP.Net Core, all parameter options are related in a Program class and with it's name and which can be used in the Response Cache attribute to remove duplicate parameter settings.

Cache3 is a new cache profile that has a time duration of 3 minutes and a location of the public.

builder.Services.AddControllers (option =>
{
   option.Cache Profiles.Add("Cache3",
      new CacheProfile()
      {
          Duration= 180,
          Location = ResponseCacheLocation.Any
      });
});
C#
public class HomeController: Controller
{
    [HttpGet]
    [ResponseCache (Cache ProfileName ="Cache3")]
     public IActionResult getCache()
     {
          return Ok ($"Responses are generated on (DateTime.Now}");
     }
}
C#
The defined cache-control response (see below):

cache-control: public,max-age=180

Caching Middleware 
Middleware can be written to add a response cache, but this implementation adds a response cache to every page.

Program.cs File

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
builder.Services.AddResponseCaching();

var app = builder.Build();

app.MapControllers();
app.UseResponseCaching () ;
app.Run();
C#
​public class HomeController: Controller
{
    [HttpGet]
    [ResponseCache(Duration = 180, Location = ResponseCacheLocation.Any, VaryByQueryKeys = new string[] { "Id" })]
    public IActionResult getCache(int Id)
    {
        return Ok($"Responses are generated on Id:{Id} at {DateTime.Now}");
    }
}
C#
First, add the response caching middleware using the AddResponseCaching() method, then configure the app to use it with UseResponseCaching().

That's it. Response caching middleware has been enabled, so VaryByQueryKeys should now work.

Let us start the application and navigate to the /Home?id=1 endpoint:

The response was generated for Id:1 at 23-05-2022 05:52:50

Changing the query string resulted in a new response from the server.

Let's change the query string to /Home?id=2:

The response was generated for Id:2 at 23-05-2022 05:53:45
----------------------------------
VieBag, ViewData, Tempdata, Session:
The following are the scenarios where we can use these objects.

Pass the data from Controller to View.
Pass the data from one action to another action in the same Controller.
Pass the data in between Controllers.
Pass the data between consecutive requests.

ViewBag is a DYNAMIC object to pass the data from Controller to View. And, this will pass the data as a property of object ViewBag. And we have NO NEED TO TYPECAST to read the data or for null checking. The scope of ViewBag is permitted to the CURRENT request and the value of ViewBag will become null while redirecting.

ViewData is a DICTIONARY object to pass the data from Controller to View where data is passed in the form of key-value pair. And TYPECASTING is required to read the data in View if the data is complex and we need to ensure null check to avoid null exceptions. The scope of ViewData is similar to ViewBag and it is restricted to the CURRENT request and the value of ViewData will become null while redirecting

TempData is a DICTIONARY object to pass the data from one action to other action in the same Controller or different Controllers. Usually, TempData object will be stored in a session object. Tempdata is also required to typecast and for null checking before reading data from it. TempData scope is limited to the NEXT request and if we want Tempdata to be available even further, we should use Keep and peek

The Keep function is used to preserve the data of TempData object even after the value is read while the Peek function is used to read the value without clearing it
@TempData["Message"]
    @{
       TempData.Keep("Message");
    }
	
@TempData.Peek("Message")

the only scenario where using TempData will reliably work is when you are redirecting. This is because a redirect kills the current request (and sends HTTP status code 302 Object Moved to the client), then creates a new request on the server to serve the redirected view

Session:
A session is the way to store information to be used across multiple pages. unlike a cookie their information is not stored on users computer 
HttpContext.Session.SetString(SessionName, "Jarvik");  
HttpContext.Session.SetInt32(SessionAge, 24);
ViewBag.Name = HttpContext.Session.GetString(SessionName);  
ViewBag.Age = HttpContext.Session.GetInt32(SessionAge);

				services.AddDistributedMemoryCache();  
				services.AddSession(options => {  
					options.IdleTimeout = TimeSpan.FromMinutes(1);//You can set Time   
				});  
				app.UseSession();  
----------------------------------
What are cookies?

cookies are text files with small pieces of data which is stored in the clients/end users computer regarding the websites.
info like likings, surfing, state management 
session info
application in inspect
Microsoft.AspNetCore.Http" namespace
//read cookie from IHttpContextAccessor  
string cookieValueFromContext = _httpContextAccessor.HttpContext.Request.Cookies["key"];  

//read cookie from Request object  
string cookieValueFromReq = Request.Cookies["Key"];  

public void Set(string key, string value, int? expireTime)  
{  
   CookieOptions option = new CookieOptions();  

   if (expireTime.HasValue)  
         option.Expires = DateTime.Now.AddMinutes(expireTime.Value);  
   else  
         option.Expires = DateTime.Now.AddMilliseconds(10);  
   
   Response.Cookies.Append(key, value, option);  
}   

      Response.Cookies.Delete(key);  


ALL about cookies:-------------------------------

public class HomeController : Controller  
{  
    private readonly IHttpContextAccessor _httpContextAccessor;  
  
    public HomeController(IHttpContextAccessor httpContextAccessor)  
    {  
        this._httpContextAccessor = httpContextAccessor;  
    }  
    public IActionResult Index()  
    {  
        //read cookie from IHttpContextAccessor  
        string cookieValueFromContext = _httpContextAccessor.HttpContext.Request.Cookies["key"];  
        //read cookie from Request object  
        string cookieValueFromReq = Request.Cookies["Key"];  
        //set the key value in Cookie  
        Set("kay", "Hello from cookie", 10);  
        //Delete the cookie object  
        Remove("Key");  
        return View();  
    }  
    /// <summary>  
    /// Get the cookie  
    /// </summary>  
    /// <param name="key">Key </param>  
    /// <returns>string value</returns>  
    public string Get(string key)  
    {  
        return Request.Cookies[Key];  
    }  
    /// <summary>  
    /// set the cookie  
    /// </summary>  
    /// <param name="key">key (unique indentifier)</param>  
    /// <param name="value">value to store in cookie object</param>  
    /// <param name="expireTime">expiration time</param>  
    public void Set(string key, string value, int? expireTime)  
    {  
        CookieOptions option = new CookieOptions();  
        if (expireTime.HasValue)  
            option.Expires = DateTime.Now.AddMinutes(expireTime.Value);  
        else  
            option.Expires = DateTime.Now.AddMilliseconds(10);  
            Response.Cookies.Append(key, value, option);  
    }  
    /// <summary>  
    /// Delete the key  
    /// </summary>  
    /// <param name="key">Key</param>  
    public void Remove(string key)  
    {  
        Response.Cookies.Delete(key);  
    }  
}   

Options
Domain - The domain you want to associate with cookie
Path - Cookie Path
Expires - The expiration date and time of the cookie
HttpOnly - Gets or sets a value that indicates whether a cookie is accessible by client-side script or not.
Secure - Transmit the cookie using Secure Sockets Layer (SSL) that is, over HTTPS only.  
----------------------------------
All about sessions:

services.AddDistributedMemoryCache();//To Store session in Memory, This is default implementation of IDistributedCache    
services.AddSession();  
app.UseCookiePolicy();      
app.UseSession();      
app.UseMvc(routes =>
app.UseCookiePolicy();   
var a = this.HttpContext.Session.GetString("login");    
HttpContext.Session.SetString("login", dto.Login);  
How to access Session in Non-Controller class?
 
Now, you don't have System.Web.HttpContext.Current.Session in ASP.NET Core. To access session in non-controller class -
First, register the following service in Startup.ConfigureServices;
services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();  
Now, register a class (example - TestManager) where you want to access the Session in Startup.ConfigureServices;
services.AddScoped<TestManager>();  
Note
You may use AddTransient or AddSingleton according to your logic.

Now, in TestManager class, add the following code.
private readonly IHttpContextAccessor _httpContextAccessor;    
private readonly ISession _session;    
public TestManager(IHttpContextAccessor httpContextAccessor)    
   {    
        _httpContextAccessor = httpContextAccessor;    
        _session = _httpContextAccessor.HttpContext.Session;    
    }  
The above code is receiving IHttpContextAccessor object through dependency injection and then, it is storing Sessions in a local variable. 
 
How to access Session in View file?
 
Add the following at the top of your View file.
@using Microsoft.AspNetCore.Http    
@inject IHttpContextAccessor httpContextAccessor   
Then, you may access the Session variable in your View like following.
@httpContextAccessor.HttpContext.Session.GetString("login")  

----------------------------------
What is session management and why need it?

HTTP is a stateless protocol
req>mvc serves response> it forgets everything
so everytime its a fresh new user, standalone and if want to remember then proper session management i.e maintain states between request
----------------------------------
Various ways of doing session management in MVC core?

1. SESSION VARIABLE:   {cookies??????,localstorage?????,sessionstorage?????}
HttpContext.Session to set and get data
2. ViewData[]
3. TempData[]
4. ViewBag[]

ViewData VS ViewBag VS TempData
 
ViewData ViewBag TempData

Viewdata:It is Key-Value Dictionary collection	
Viewbag:It is a type object	
Tempdata:It is Key-Value Dictionary collection

ViewData is a dictionary object and it is property of ControllerBase class	
ViewBag is Dynamic property of ControllerBase class.	
TempData is a dictionary object and it is property of controllerBase class.

ViewData is Faster than ViewBag	
ViewBag is slower than ViewData	
NA

ViewData is introduced in MVC 1.0 and available in MVC 1.0 and above	
ViewBag is introduced in MVC 3.0 and available in MVC 3.0 and above	
TempData is also introduced in MVC1.0 and available in MVC 1.0 and above.

ViewData also works with .net framework 3.5 and above	
ViewBag only works with .net framework 4.0 and above	
TempData also works with .net framework 3.5 and above

Type Conversion code is required while enumerating	
In depth, ViewBag is used dynamic, so there is no need to type conversion while enumerating.	
Type Conversion code is required while enumerating

Viewdata:Its value becomes null if redirection has occurred.	
Viewbag:Same as ViewData	
TempData is used to pass data between two consecutive requests.

Viewdata:It lies only during the current request.	
Viewbag:Same as ViewData	
TempData only works during the current and subsequent request

ViewModel:
create model,
in controller: List<Friend> lst=new..{new Friend{id...}..
return View(lst);
in view: @foreach(var i in Model){<p>@i.Id...}

+++++++++++++++++++++++++++

NOTE:   
Now look at one more beauty of MVC, you can put data into the ViewBag and access it from ViewData or put data in the ViewData and access it from the ViewBag, here you have all the freedom.
 
ViewData:
ViewData is a dictionary object that is derived from ViewDataDictionary class.
ViewData[“KeyName”] = “Some Data”;
Since ViewData is a server-side code, hence to use it on view, we need to use the razor syntax i.e. @
@ViewData[“KeyName”]

public ViewDataDictionary ViewData { get; set; }
ViewData is a property of ControllerBase class.

ViewData is used to pass data from controller to corresponding view.

It’s life lies only during the current request.

If redirection occurs then it’s value becomes null.

It’s required typecasting for getting data and check for null values to avoid error.

ViewBag
ViewBag.Title = "Student Details Page";
@ViewBag.Title
ViewBag is a dynamic property that takes advantage of the new dynamic features in C# 4.0.

Basically it is a wrapper around the ViewData and also used to pass data from controller to corresponding view.

public Object ViewBag { get; }
ViewBag is a property of ControllerBase class.

It’s life also lies only during the current request.

If redirection occurs then it’s value becomes null.

It doesn’t required typecasting for getting data.


TempData
TempData["name"] = "Bill";
if(TempData.ContainsKey("name"))
            name = TempData["name"].ToString();
@TempData["name"]
TempData is a dictionary object that is derived from TempDataDictionary class and stored in short lives session.

public TempDataDictionary TempData { get; set; }
TempData is a property of ControllerBase class.

TempData is used to pass data from current request to subsequent request (means redirecting from one page to another).

It’s life is very short and lies only till the target view is fully loaded.

It’s required typecasting for getting data and check for null values to avoid error.

It is used to store only one time messages like error messages, validation messages. To persist data with TempData refer this article: Persisting Data with TempData

Session
HttpContext.Session.SetString(SessionName, "Jarvik");  
            HttpContext.Session.SetInt32(SessionAge, 24);
 ViewBag.Name = HttpContext.Session.GetString(SessionName);  
            ViewBag.Age = HttpContext.Session.GetInt32(SessionAge);

In ASP.NET MVC, Session is a property of Controller class whose type is HttpSessionStateBase.

public HttpSessionStateBase Session { get; }
Session is also used to pass data within the ASP.NET MVC application and Unlike TempData, it persists for its expiration time (by default session expiration time is 20 minutes but it can be increased).

Session is valid for all requests, not for a single redirect.

It’s also required typecasting for getting data and check for null values to avoid error
----------------------------------
STATE MANAGEMENT:

1. cookies
2. session
3. hidden fields
4. Tempdata
5. querystring

Understanding state management
ASP.NET Core MVC provides a rich set of features for building modern web applications, and these include support for a number of ways to manage state. State management is the technique of maintaining the state of an application over time, i.e., for the duration of a user session or across all of the HTTP requests and responses that constitute the session. Thus it is one of the most important cross-cutting concerns of any web application.

In other words, state management is how you keep track of the data moving in and out of your application and how you ensure it’s available when needed. State management allows a smoother user experience by enabling users to pick up where they left off without re-entering their information. Without state management, users would have to enter their information every time they visited or reloaded a new page.

Nominations are open for the 2024 Best Places to Work in IT
You can manage the state in several ways in an ASP.NET Core MVC application. We’ll examine six ways to handle state in the sections below: cookies, session state, hidden fields, the TempData property, query strings, and caching.

Use cookies to maintain state in ASP.NET Core MVC
A cookie is a piece of data that resides on the user’s computer that helps identify the user. In most web browsers, each cookie is saved in a separate file (the exception is Firefox, which saves all cookies in the same file). Cookies are represented as key-value pairs, and the keys can be used to read, write, or remove cookies. ASP.NET Core MVC uses cookies to preserve session state; the cookie with the session ID is transmitted to the client.

You can use the code snippet given below to write data to a cookie.

CookieOptions options = new CookieOptions();
options.Expires = DateTime.Now.AddSeconds(10);
Use session state to maintain state in ASP.NET Core MVC
Session state is a mechanism for storing user data on the server side in an ASP.NET Core MVC web application. A user’s browser sends the server a request containing information about the user’s session every time the user visits a website. The server then creates a new session and stores the user’s data in that session.

The user’s session and all the user’s data are destroyed when they leave the website. Session state is useful for storing small amounts of data that need to be persisted across multiple requests from a single user. For example, you might use session state to store a user’s shopping cart items or preferences.

The following code snippet illustrates how you can store a key-value pair in the session state in an action method.

public IActionResult Index()
{
   HttpContext.Session.SetString("MyKey", "MyValue");
   return View();
}
Use hidden fields to maintain state in ASP.NET Core MVC
When working on ASP.NET Core MVC applications, we may need to preserve data on the client side instead of presenting it on the page. For example, we might need to send data to the server when the user takes a certain action, without showing the data in the user interface. This is a typical problem in many applications, and hidden fields offer an excellent solution. We can store information in hidden form fields and return it in the following request.

The following code snippet illustrates how you can store the user ID of a logged in user and assign the value 1.

@Html.HiddenFor(x => x.UserId, new { Value = "1" })
Use TempData to maintain state in ASP.NET Core MVC
You can use the TempData property in ASP.NET Core to store data until your application reads it. We can examine the data without deleting it using the Keep() and Peek() functions. TempData is extremely helpful when we need data belonging to more than one request. We can get to them using controllers and views.

TempData is used to transmit data from one request to the next, i.e., to redirect data from one page to another. It has a minimal life and only exists until the target view is entirely loaded. However, you may save data in TempData by using the Keep() function. TempData is accessible only during a user’s session. It survives until we read it and then it’s cleared after an HTTP request.

The following code snippet illustrates how you can use TempData in your ASP.NET Core MVC controller.

public class CustomerController : Controller
{
    public IActionResult TempDataDemo()
    {
        var customerId = TempData["CustomerId"] ?? null;       
        return View();
    }
}
Use query strings to maintain state in ASP.NET Core MVC
You can take advantage of query strings to transmit a small amount of data from one request to another. Note that because query strings are publicly exposed, you should never use them to pass sensitive data. Additionally, using query strings could make your application vulnerable to cross-site request forgery (CSRF) attacks.

The following code snippet illustrates how you can use query strings in ASP.NET Core MVC.

http://localhost:5655/api/customer?region=abc
And, the code snippet below shows how you can read the query string data in your action method.

string region = HttpContext.Request.Query["region"].ToString();
Use caching to maintain state in ASP.NET Core MVC
Caching is yet another way to store state information between requests. You can leverage a cache to store stale data, i.e., data that changes infrequently in your application. ASP.NET Core MVC provides support for three different types of caching, namely in-memory caching, distributed caching, and response caching. The following code snippet shows how you can turn on in-memory caching in your ASP.NET Core MVC applications.

builder.Services.AddMemoryCache();
If you would like to store and retrieve instances of complex types in the session state, you can serialize or deserialize your data as appropriate. And if you’d like to send data from your controller to the view, you can take advantage of ViewData.
----------------------------------
Ways of passing data from views to controllers:

Using Traditional approach ;;           Request["txtAmount"].ToString()
Using the FormCollection Object ;;      Action(FormCollection form) .. form["txtAmount"].ToString()
Using the Parameters;;                  CalculateSimpleInterestResult(string txtAmount, string txtRate, string txtYear)
Strongly type model binding to view ;;  SimpleInterestModel model = new SimpleInterestModel();return View(model); 
										@model 	CalculateSimpleInterest.Models.SimpleInterestModel  
										@Model.xyz


1.In the traditional approach we use the request object of the HttpRequestBase class. The request object has view input field values in name/value pairs. When we create a submit button then the request type POST is created and calls the POST method.
decimal principle = Convert.ToDecimal(Request["txtAmount"].ToString());
StringBuilder sbInterest = new StringBuilder();  
    sbInterest.Append("<b>Amount :</b> " + principle+"<br/>");  
    sbInterest.Append("<b>Rate :</b> " + rate + "<br/>");  
    sbInterest.Append("<b>Time(year) :</b> " + time + "<br/>");  
    sbInterest.Append("<b>Interest :</b> " + simpleInteresrt);  
    return Content(sbInterest.ToString());  
	
2.FormCollection Object:

public ActionResult CalculateSimpleInterestResult(FormCollection form)  
{  
    decimal principle = Convert.ToDecimal(form["txtAmount"].ToString()); 
3.Parameters:
public ActionResult CalculateSimpleInterestResult(string txtAmount, string txtRate, string txtYear)  
{  
    decimal principle = Convert.ToDecimal(txtAmount); 

4.
Strongly type model binding to view
We bind a model to the view; that is called strongly type model binding.
namespace CalculateSimpleInterest.Models  
{  
    public class SimpleInterestModel  
    {  
        public decimal Amount { get; set; }  
        public decimal Rate { get; set; }  
        public int Year { get; set; }  
    }  
}  
Create an action method that render a view on the UI
 
We are passing an empty model to be bound to the view.
public ActionResult SimpleInterest()  
{  
    SimpleInterestModel model = new SimpleInterestModel();  
    return View(model);  
}  
Step 3
 
Create a strongly typed view that has the same screen as in Figure 1.1
@model CalculateSimpleInterest.Models.SimpleInterestModel  
   
@{  
    ViewBag.Title = "SimpleInterest";  
}  
   
<h2>Calulate Simple Interest</h2>  
   
@using (Ajax.BeginForm("CalculateSimpleInterestResult","CalculateSimpleInterest",  
                            new AjaxOptions { UpdateTargetId = "divInterestDeatils" }))  
    {  
         
    <fieldset>  
        <legend>Calulate Simple Interest</legend>  
        <div id="divInterestDeatils"></div>  
   
        <div class="editor-label">  
            @Html.LabelFor(model => model.Amount)  
        </div>  
        <div class="editor-field">  
            @Html.EditorFor(model => model.Amount)            
        </div>  
   
        <div class="editor-label">  
            @Html.LabelFor(model => model.Rate)  
        </div>  
[HttpPost]  
public ActionResult CalculateSimpleInterestResult(SimpleInterestModel model)  
{  
    decimal simpleInteresrt = (model.Amount*model.Year*model.Rate)/100; 
----------------------------------
Passing Data From One Controller To Another In ASP.NET MVC
At times you need to pass data from an action method belonging to one controller to an action method belonging to another controller. There are three ways to accomplish this task. They are:

1.Pass data as query string parameters
2.Pass data in TempData dictionary
3.Pass data as route parameters

1...string url=string.Format("/home2/index?customerid={0}
               &customername={1}&country={2}",
               data.CustomerID,data.CustomerName,data.Country);
    return Redirect(url);
data.CustomerName = Request.QueryString["CustomerName"]; //Request["txtAmount"].ToString()

2...TempData["mydata"] = data;
    return RedirectToAction("Index", "Home2");
Customer data = TempData["mydata"] as Customer;


3...routes.MapRoute(
    name: "Default2",
    url: "{controller}/{action}/
          {customerid}/{customername}/{country}",
    defaults: new { controller = "Home2", action = "Index" }
);

public ActionResult Index1()
{
    Customer data = new Customer()
    {
        CustomerID = 1,
        CustomerName = "Abcd",
        Country = "USA"
    };
    return RedirectToAction("Index", "Home2", data);
}

public ActionResult Index()
{
    Customer data = new Customer();
    UpdateModel(data);
    return View(data);
}

/*
UpdateModel() is a Controller helper method that attempts to bind a bunch of different input data sources (HTTP POST data coming from a View, QueryString values, Session variables/Cookies, etc.) to the explicit model object you indicate as a parameter. Essentially, it is only for model binding.

If you express the input parameters for your Action as a strongly-typed model (like a View Model), you've already taken all of the steps that are done behind the scenes when UpdateModel() is called. If you retrieve an object from the DataContext and edit its properties, SaveChanges() is all you need to push the updates back to the database (in this case, Save()).
*/

// OR

public ActionResult Index(Customer data)
{
    return View(data);
}

Note about query string and route parameters
Before I conclude this post, it would be interesting to see a small thing about how RedirectToAction() deals with query string and route parameters.

Let's assume that your sender action is like this:

public ActionResult Index()
{
    Customer data = new Customer()
    {
        CustomerID = 1,
        CustomerName = "Abcd",
        Country = "USA"
    };
    return RedirectToAction("Index", "Home2", data);
}
Notice that RedirectToAction() method passes Customer data object to Index() of Home2 as the third parameter.

The interesting thing to note is - If you haven't defined any route to match the data MVC sends it as query string. And if you have defined a route, it passes the values as route parameters. You can confirm this by observing the browser address bar once the Index() of Home2 renders the view. The following figure shows the difference:

http://localhost:5655/home/index?customerid=abc&customername=sam
http://localhost:5655/api/customer?region=abc


That also means in the query string technique discussed earlier, you could have used exactly same code in the receiving action as in the case of route parameter technique.

In addition to the three techniques discussed above you can also use Session object but that's not discussed here separately since TempData technique anyway depends on the session storage	

----------------------------------
.net core 6+ :

using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);
//Register services here
builder.Services.AddDbContext<ApplicationDbContext>(options => options.UseSqlServer(       
						builder.Configuration.GetConnectionString("DefaultConnection")       
						));
builder.Services.AddScoped<IUnitOfWork, UnitOfWork>();
//builder.Services.AddAuthentication(...)
services.AddDistributedMemoryCache();  
services.AddSession();
services.AddControllersWithViews(options =>
											{
												options.Filters.Add(typeof(CustomExceptionFilter));
											});
//services.AddScoped<CustomActionFilter>();//[ServiceFilter(typeof(typeof YourActionFilter))]
				
var app = builder.Build();
//app.UseAuthentication();
app.UseSession();
app.UseMiddleware<ExceptionHandleMiddleware>();
-----------------------
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
builder.Services.AddSingleton<IDataService, DataService>();
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}
app.UseHttpsRedirection();
app.UseRouting();
app.UseAuthorization();
app.MapControllers();
app.Run();

----------------------------------
ASP.net Page life cycle:?

ASP.NET Application Life Cycle
The application life cycle has the following stages:

User makes a request for accessing application resource, a page. Browser sends this request to the web server.

A unified pipeline receives the first request and the following events take place:

An object of the class ApplicationManager is created.

An object of the class HostingEnvironment is created to provide information regarding the resources.

Top level items in the application are compiled.

Response objects are created. The application objects such as HttpContext, HttpRequest and HttpResponse are created and initialized.

An instance of the HttpApplication object is created and assigned to the request.

The request is processed by the HttpApplication class. Different events are raised by this class for processing the request.

ASP.NET Page Life Cycle
When a page is requested, it is loaded into the server memory, processed, and sent to the browser. Then it is unloaded from the memory. At each of these steps, methods and events are available, which could be overridden according to the need of the application. In other words, you can write your own code to override the default code.

The Page class creates a hierarchical tree of all the controls on the page. All the components on the page, except the directives, are part of this control tree. You can see the control tree by adding trace= "true" to the page directive. We will cover page directives and tracing under 'directives' and 'event handling'.

The page life cycle phases are:

Initialization
Instantiation of the controls on the page
Restoration and maintenance of the state
Execution of the event handler codes
Page rendering

Understanding the page cycle helps in writing codes for making some specific thing happen at any stage of the page life cycle. It also helps in writing custom controls and initializing them at right time, populate their properties with view-state data and run control behavior code.

Following are the different stages of an ASP.NET page:

Page request - When ASP.NET gets a page request, it decides whether to parse and compile the page, or there would be a cached version of the page; accordingly the response is sent.

Starting of page life cycle - At this stage, the Request and Response objects are set. If the request is an old request or post back, the IsPostBack property of the page is set to true. The UICulture property of the page is also set.

Page initialization - At this stage, the controls on the page are assigned unique ID by setting the UniqueID property and the themes are applied. For a new request, postback data is loaded and the control properties are restored to the view-state values.

Page load - At this stage, control properties are set using the view state and control state values.

Validation - Validate method of the validation control is called and on its successful execution, the IsValid property of the page is set to true.

Postback event handling - If the request is a postback (old request), the related event handler is invoked.

Page rendering - At this stage, view state for the page and all controls are saved. The page calls the Render method for each control and the output of rendering is written to the OutputStream class of the Response property of page.

Unload - The rendered page is sent to the client and page properties, such as Response and Request, are unloaded and all cleanup done.

ASP.NET Page Life Cycle Events
At each stage of the page life cycle, the page raises some events, which could be coded. An event handler is basically a function or subroutine, bound to the event, using declarative attributes such as Onclick or handle.

Following are the page life cycle events:

PreInit - PreInit is the first event in page life cycle. It checks the IsPostBack property and determines whether the page is a postback. It sets the themes and master pages, creates dynamic controls, and gets and sets profile property values. This event can be handled by overloading the OnPreInit method or creating a Page_PreInit handler.

Init - Init event initializes the control property and the control tree is built. This event can be handled by overloading the OnInit method or creating a Page_Init handler.

InitComplete - InitComplete event allows tracking of view state. All the controls turn on view-state tracking.

LoadViewState - LoadViewState event allows loading view state information into the controls.

LoadPostData - During this phase, the contents of all the input fields are defined with the <form> tag are processed.

PreLoad - PreLoad occurs before the post back data is loaded in the controls. This event can be handled by overloading the OnPreLoad method or creating a Page_PreLoad handler.

Load - The Load event is raised for the page first and then recursively for all child controls. The controls in the control tree are created. This event can be handled by overloading the OnLoad method or creating a Page_Load handler.

LoadComplete - The loading process is completed, control event handlers are run, and page validation takes place. This event can be handled by overloading the OnLoadComplete method or creating a Page_LoadComplete handler

PreRender - The PreRender event occurs just before the output is rendered. By handling this event, pages and controls can perform any updates before the output is rendered.

PreRenderComplete - As the PreRender event is recursively fired for all child controls, this event ensures the completion of the pre-rendering phase.

SaveStateComplete - State of control on the page is saved. Personalization, control state and view state information is saved. The HTML markup is generated. This stage can be handled by overriding the Render method or creating a Page_Render handler.

UnLoad - The UnLoad phase is the last phase of the page life cycle. It raises the UnLoad event for all controls recursively and lastly for the page itself. Final cleanup is done and all resources and references, such as database connections, are freed. This event can be handled by modifying the OnUnLoad method or creating a Page_UnLoad handler.

+++++++++++++++++++++++++++++++++++++++

What is View state and how does it work in ASP.Net?

A web application is stateless. That means that a new instance of a page is created every time when we make a request to the server to get the page and after the round trip our page has been lost immediately. It only happens because of one server, all the controls of the Web Page is created and after the round trip the server destroys all the instances. So to retain the values of the controls we use state management techniques.

State Management technique 2 categories:
1. Client Side: View State, Control State, Hidden Fields, Cookies, Query Strings
2. Server Side: Application state, Session state, Profile properties

View State
 
View State is the method to preserve the Value of the Page and Controls between round trips. It is a Page-Level State Management technique. View State is turned on by default and normally serializes the data in every control on the page regardless of whether it is actually used during a post-back


Features Of View State
 
These are the main features of view state,
Retains the value of the Control after post-back without using a session.
Stores the value of Pages and Control Properties defined in the page.
Creates a custom View State Provider that lets you store View State Information in a SQL Server Database or in another data store.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
NOTE: 
View state is used only in ASP.net forms,controls and Page life cycle. View state is used by ASP.net framework to manage control states.

ViewState["Message"] = "Hello RAJESH!";

View Data is a dataset or Data which is passed to your View - to dipslay HTML data in MVC
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
PASSING DATA TO VIEWS!

Session["FirstName"] = FirstNameTextBox.Text;
ViewData["Message"] = "Hello RAJESH!";
ViewBag.Message = "Hello RAJESH!";
TempData["Message"] = "Hello RAJESH!";

Session:
The Session is also used to pass data within the ASP.NET MVC application and Unlike TempData, it persists for its expiration time (by default session expiration time is 20 minutes but it can be increased).

The Session is valid for all requests, not for a single redirect.

 It also requires typecasting for getting data and checks for null values to avoid error
 
ViewData:
ViewData is derived from the ViewDataDictionary class and is basically a Dictionary object i.e., Keys and Values where Keys are String while Values will be objects.
Data is stored as Object in ViewData.
While retrieving the data it needs to be Type Cast to its original type as the data is stored as the object and it also requires NULL checks while retrieving.
ViewData is used for passing value from Controller to View.
ViewData is available only for Current Request. It will be destroyed on redirection
ViewData[“KeyName”] = “Some Data”;
@ViewData[“KeyName”]

@foreach (var std in (List<string>)ViewData["Students"])  
//OR  
@foreach (var std in (IEnumerable<string>)ViewData["Students"]) 

ViewBag:
ViewBag is a Wrapper built around ViewData.
ViewBag is a dynamic property and it makes use of the C# 4.0 dynamic features.
While retrieving, there is no need for Type Casting data.
ViewBag is used for passing value from Controller to View.
ViewBag is available only for Current Request. It will be destroyed on redirection.
ViewBag.KeyName = “Some Data”;
@ViewBag.KeyName

TempData:
TempData is derived from the TempDataDictionary class and is basically a Dictionary object i.e. Keys and Values where Keys are String while Values will be objects.
Data is stored as Object in TempData.
While retrieving the data it needs to be Type Cast to its original type as the data is stored as objects and it also requires NULL checks while retrieving.
TempData can be used for passing value from Controller to View and also from Controller to Controller.
TempData is available for Current and Subsequent Requests. It will not be destroyed on redirection.
TempData["name"]="haris";

if(TempData.ContainsKey("name"))
name = TempData["name"].ToString();


Viewdata and tempdata are KEY-VALUE dictionary collection where as Viewbag is a type object
Viewdata and tempdata are ViewData are dictionary object and are property of ControllerBase class	 where as viewbag is Dynamic property of ControllerBase class
ViewData is Faster than ViewBag
Viewdata and tempdata require type conversion but not ViewBag
Viewdata and viewbag Its value becomes null if redirection has occurred but TempData is used to pass data between two consecutive requests
Viewdata and viewbag lies only during the current request but TempData only works during the current and subsequent request




-------------------------------

fromservice: 

Sometimes, we require dependency on the particular controller action method not throughout the controller. ASP.net core MVC allows us to inject the dependency to particular action using the "FromServices" attribute. This attribute tells the ASP.net core framework that parameters should be retrieved from the service container.

using DepedencyInjectionExample.Service;
using Microsoft.AspNetCore.Mvc;

namespace DepedencyInjectionExample.Controllers
{
 public class DemoController : Controller
 {
 public IActionResult Index([FromServices] IHelloWorldService helloWorldService)
 {
 ViewData["MyText"] = helloWorldService.SaysHello() + "Jignesh!";
 return View();
 }
 }
}


another way: 

There is another way to get dependency services from the service container. In this method, the service is not injected in the controller constructor or in the action method as a parameter. Using method "GetService" of the "HttpContext.RequestServices" property, we can get dependent services configured with the Service container. This is also known as property injection. Following is the example.

public IActionResult Index1()
{
 var helloWorldService = (IHelloWorldService)this.HttpContext.RequestServices.GetService(typeof(IHelloWorldService));
 ViewData["MyText"] = helloWorldService.SaysHello() + "Jignesh Trivedi!";
 return View("index");
}

----------------------------------
GENERIC rest api call:
public class HttpClientService<TResult> : IDisposable where TResult : class
{
    private HttpClient client = new HttpClient();

    // Constructor: Initializes the HttpClient with base URL and sets default settings
    public HttpClientService(string baseUrl)
    {
        client.BaseAddress = new Uri(baseUrl);
        client.DefaultRequestHeaders.Accept.Clear();
        client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
        client.Timeout = new TimeSpan(0, 30, 0); // Timeout set to 30 minutes
    }

    // Method for making a GET request to an API
    public TResult GetAPI(string url, Dictionary<string,string> urlParameters = null, Dictionary<string, string> headers = null)
    {
        string parameters = string.Empty;

        // If there are URL parameters, append them to the URL
        if (urlParameters != null)
        {
            parameters = BuildURLParametersString(urlParameters);
            url = string.IsNullOrEmpty(parameters) ? url : url + parameters;
        }

        // If there are custom headers, add them to the request
        if (headers != null)
        {
            AddHeaders(headers);
        }

        // Send GET request synchronously (using Task.Run to avoid async/await in constructors)
        var response = Task.Run(() => client.GetAsync(url)).Result;

        // Read and deserialize the response content
        var apiResult = response.Content.ReadAsStringAsync().Result;
        var result = JsonConvert.DeserializeObject<TResult>(apiResult);
        return result;
    }

    // Method for making a POST request to an API
    public TResult PostAPI(string url, Dictionary<string, string> formParameters = null, string jsonString = "", Dictionary<string, string> headers = null)
    {
        HttpContent contentPost = null;

        // If there are custom headers, add them to the request
        if (headers != null)
        {
            AddHeaders(headers);
        }

        // Prepare content for POST request (either form parameters or JSON string)
        if (formParameters != null)
        {
            var formContent = new FormUrlEncodedContent(formParameters);
            contentPost = formContent;
        }
        else if (!string.IsNullOrEmpty(jsonString))
        {
            var content = new StringContent(jsonString, Encoding.UTF8, "application/json");
            contentPost = content;
        }

        // Send POST request synchronously
        var response = Task.Run(() => client.PostAsync(url, contentPost)).Result;

        // Read and deserialize the response content
        var apiResult = response.Content.ReadAsStringAsync().Result;
        var result = JsonConvert.DeserializeObject<TResult>(apiResult);
        return result;
    }

    // Helper method to build URL parameters
    private String BuildURLParametersString(Dictionary<string, string> parameters)
    {
        UriBuilder uriBuilder = new UriBuilder();
        var query = System.Web.HttpUtility.ParseQueryString(uriBuilder.Query);
        foreach (var urlParameter in parameters)
        {
            query[urlParameter.Key] = urlParameter.Value;
        }
        uriBuilder.Query = query.ToString();
        return uriBuilder.Query;
    }

    // Helper method to add custom headers to the request
    private void AddHeaders(Dictionary<string, string> headers)
    {
        foreach (var header in headers)
        {
            if (!string.IsNullOrEmpty(header.Value))
            {
                client.DefaultRequestHeaders.Add(header.Key, header.Value);
            }
        }
    }

    // IDisposable implementation: Dispose of the HttpClient
    public void Dispose()
    {
        client.Dispose();
    }
}


SendRequest method determines whether to make a GET or POST request based on the presence of a request body (jsonString or formParameters). It then handles the request and response accordingly. 

public TResult SendRequest(string url, Dictionary<string, string> urlParameters = null, 
                               Dictionary<string, string> formParameters = null, 
                               string jsonString = "", Dictionary<string, string> headers = null)
    {
        string parameters = string.Empty;

        // If there are URL parameters, append them to the URL
        if (urlParameters != null)
        {
            parameters = BuildURLParametersString(urlParameters);
            url = string.IsNullOrEmpty(parameters) ? url : url + parameters;
        }

        // If there are custom headers, add them to the request
        if (headers != null)
        {
            AddHeaders(headers);
        }

        // Determine whether to make a GET or POST request
        HttpResponseMessage response;
        if (!string.IsNullOrEmpty(jsonString))
        {
            var content = new StringContent(jsonString, Encoding.UTF8, "application/json");
            response = Task.Run(() => client.PostAsync(url, content)).Result;
        }
        else if (formParameters != null)
        {
            var formContent = new FormUrlEncodedContent(formParameters);
            response = Task.Run(() => client.PostAsync(url, formContent)).Result;
        }
        else
        {
            response = Task.Run(() => client.GetAsync(url)).Result;
        }

        // Read and deserialize the response content
        var apiResult = response.Content.ReadAsStringAsync().Result;
        var result = JsonConvert.DeserializeObject<TResult>(apiResult);
        return result;
    }
------------------------
JWT AUTH:
.net core 6 program.cs:

The complete code of our Program.cs file to this point looks like this:

C#
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Authorization;

var builder = WebApplication.CreateBuilder(args);
// REGISTER SERVICES HERE
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer();
builder.Services.AddAuthorization();
var app = builder.Build();
// REGISTER MIDDLEWARE HERE
app.UseAuthentication();
app.UseAuthorization();
app.MapGet("/", [Authorize] () => {
    return "Hello World!";
});
app.Run();
+++++++++++++++++++++
To add the JwtToken to the headers in each request pipeline:
app.Use(async (context, next) =>
            {
                var token = context.Session.GetString("JwtToken");
                if (!string.IsNullOrEmpty(token))
                {
                    context.Request.Headers.Add("Authorization", "Bearer " + token);
                }
                await next();
            });
+++++++++++++++++++++
The best place to store a JWT (JSON Web Token) for authorization purposes in a web application largely depends on the specific requirements and security considerations of your application. Here are some common options:

HTTP-Only Cookies: Storing the JWT in HTTP-only cookies is a secure approach. These cookies cannot be accessed through JavaScript, which reduces the risk of XSS (Cross-Site Scripting) attacks. The server sets the HTTP-only cookie, and it's automatically sent with each request to the server.

Local Storage: Storing JWTs in local storage is another option. It's accessible via JavaScript, which makes it convenient to use, but it's more vulnerable to XSS attacks. If an attacker can inject scripts into your web page, they can retrieve the JWT from local storage.

Session Storage: Similar to local storage, but with a shorter lifespan. Session storage persists data only for the duration of the page session. It's also vulnerable to XSS attacks in the same way as local storage.

Authorization Header: The JWT can be stored in the client's application memory (such as a variable in JavaScript) and sent with each request to the server in an Authorization header. This approach is also vulnerable to XSS attacks.

Each storage option has its trade-offs:

HTTP-only Cookies: Best for security against XSS, but can be challenging to implement in scenarios involving cross-origin requests.
Local/Session Storage: More vulnerable to XSS, but easier to implement in a single-page application (SPA) and for handling cross-origin requests.
It's essential to implement additional security measures regardless of where you store the JWT. These include using secure, HTTPS connections, implementing proper CORS (Cross-Origin Resource Sharing) policies, and ensuring your application is secure against XSS attacks.

For in-depth learning about JWT, authorization best practices, and secure web application development, you can explore courses on codedamn, which provide hands-on experience and guidance in these areas.
+++++++++++++++++++++
FULL JWT auth process:

JWT (JSON Web Token) is a popular way of implementing authentication and authorization in web applications. In .NET Core, you can use the built-in JWT middleware to implement JWT-based authentication and authorization.

{{{{{Three parts make up JSON Web Tokens, separated by a dot (.). The first two (the header and the payload) contain Base64-URL encoded JSON, while the third is a cryptographic signature.}}}}}

To use JWT-based authentication and authorization and save the token in session in .NET Core, you can follow these steps:

Add the necessary packages for JWT-based authentication and authorization by running the following commands in the Package Manager Console:

Install-Package Microsoft.AspNetCore.Authentication.JwtBearer
Install-Package System.IdentityModel.Tokens.Jwt

Configure the JWT middleware in the ConfigureServices method of the Startup class. Here's an example configuration:
public void ConfigureServices(IServiceCollection services)
{
    // ...

    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
        .AddJwtBearer(options =>
						{
							options.TokenValidationParameters = new TokenValidationParameters
							{
								ValidateIssuer = true,
								ValidateAudience = true,
								ValidateLifetime = true,
								ValidateIssuerSigningKey = true,
								ValidIssuer = Configuration["Jwt:Issuer"],
								ValidAudience = Configuration["Jwt:Audience"],
								IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration["Jwt:SecretKey"]))
							};
						}
					  );

    // ...
}

//app.UseAuthentication();
//app.UseAuthorization();

In this example, the JWT middleware is configured to validate the token issuer, audience, lifetime, and signing key. The values for these parameters are retrieved from the application configuration.

Add the [Authorize] attribute to any controller actions or controllers that require authorization.
[Authorize]
public class ProtectedController : Controller
{
    // ...
}
In this example, the ProtectedController requires authorization.

Implement a login endpoint that generates a JWT and returns it to the client.
[HttpPost("login")]
public async Task<IActionResult> Login([FromBody] LoginViewModel model)
{
    if (!ModelState.IsValid)
    {
        return BadRequest();
    }

    // Authenticate the user
    var user = await _userManager.FindByEmailAsync(model.Email);
    if (user == null)
    {
        return Unauthorized();
    }
    if (!await _userManager.CheckPasswordAsync(user, model.Password))
    {
        return Unauthorized();
    }

    // Generate a JWT
    var claims = new List<Claim>
    {
        new Claim(ClaimTypes.NameIdentifier, user.Id),
        new Claim(ClaimTypes.Name, user.Email)
    };
    var roles = await _userManager.GetRolesAsync(user);
    foreach (var role in roles)
    {
        claims.Add(new Claim(ClaimTypes.Role, role));
    }
    var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration["Jwt:SecretKey"]));
    var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
    var token = new JwtSecurityToken(
        issuer: Configuration["Jwt:Issuer"],
        audience: Configuration["Jwt:Audience"],
        claims: claims,
        expires: DateTime.UtcNow.AddHours(1),
        signingCredentials: creds
    );

    // Save the JWT in session
    HttpContext.Session.SetString("JwtToken", new JwtSecurityTokenHandler().WriteToken(token));

    return Ok();
}
In this example, the Login endpoint authenticates the user and generates a JWT containing the user's identity and roles. The JWT is then saved in session.

Use the saved JWT in subsequent requests by including it in the Authorization header of the request. Here's an example of how to include the JWT in an AJAX request using jQuery:
$.ajax({
    type: 'GET',
    url: '/api/protected',
    headers: {
        'Authorization': 'Bearer ' + sessionStorage.getItem('JwtToken')
    },
    success: function(data) {
        // Handle the response
    },
    error: function(jqXHR, textStatus, errorThrown) {
        // Handle the error
    }
});
In this example, the saved JWT is retrieved from session storage and included in the Authorization header of the AJAX request.

Use the UseSession middleware in the Configure method of the Startup class to enable session support. Here's an example configuration:
arduino
Copy code
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // ...

    app.UseSession();

    // ...
}

-------------------------------
Jquery datatable:

HTML
<table id="myTable" class="table table-striped table-bordered">
    <thead>
        <tr>
            <th>Name</th>
            <th>Age</th>
            <th>Country</th>
            <th>Actions</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>John Doe</td>
            <td>30</td>
            <td>United States</td>
            <td><a href="#">Edit</a> | <a href="#">Delete</a></td>
        </tr>
        <tr>
            <td>Jane Doe</td>
            <td>25</td>
            <td>Canada</td>
            <td><a href="#">Edit</a> | <a href="#">Delete</a></td>
        </tr>
    </tbody>
</table>
Use code with caution. Learn more
JavaScript
$(document).ready(function () {
    $('#myTable').DataTable({
        // Sorting
        order: [[0, 'asc']],

        // Filtering
        filter: true,

        // Pagination
        paging: true,
        pageLength: 10,

        // Column hiding
        columnDefs: [{
            "targets": [2],
            "visible": false
        }],

        // Column reordering
        responsive: true,

        // Exporting
        buttons: ['csv', 'excel', 'pdf'],

        // Custom properties
        ajax: {
            url: '/api/data',
            dataSrc: 'data'
        },

        // Custom variations
        dom: '<"top"f>rt<"bottom"ip>',
        buttons: {
            csv: {
                filename: 'my-table'
            }
        }
    });
});

This example shows how to use the following properties and variations:

order: Specifies the default sorting order for the table.
filter: Enables filtering of the table data.
paging: Enables pagination of the table data.
columnDefs: Specifies the columns that should be hidden.
responsive: Enables responsive table layout.
buttons: Specifies the buttons that should be displayed in the toolbar.
ajax: Specifies the URL to the data source.
dom: Specifies the HTML markup for the table.
buttons: Specifies the customizations for the buttons.
-------------------------------
REST vs SOAP:

Simple Object Access Protocol (SOAP):

SOAP builds an XML protocol on top of HTTP or sometimes TCP/IP.
SOAP describes functions, and types of data.
SOAP is a successor of XML-RPC(remote procedure call) and is very similar, but describes a standard way to communicate.
Several programming languages have native support for SOAP, you typically feed it a web service URL and you can call its web service functions without the need of specific code.
Binary data that is sent must be encoded first into a format such as base64 encoded.
Has several protocols and technologies relating to it: WSDL, XSDs, SOAP, WS-Addressing
Representational state transfer (REST):

REST need not be over HTTP but most of my points below will have an HTTP bias.
REST is very lightweight, it says wait a minute, we don't need all of this complexity that SOAP created.
Typically uses normal HTTP methods instead of a big XML format describing everything. For example to obtain a resource you use HTTP GET, to put a resource on the server you use HTTP PUT. To delete a resource on the server you use HTTP DELETE.
REST is a very simple in that it uses HTTP GET, POST and PUT methods to update resources on the server.
REST typically is best used with Resource Oriented Architecture (ROA). In this mode of thinking everything is a resource, and you would operate on these resources.
As long as your programming language has an HTTP library, and most do, you can consume a REST HTTP protocol very easily.
Binary data or binary resources can simply be delivered upon their request.
-------------------------------
HttpResponseMessage vs IHttpActionResult:

public HttpResponseMessage GetAllEmployee()
        {
            try
            {
               
                    var Employees = FetchFromDB();
                    if (Employees != null)
                    {
                        return Request.CreateResponse(HttpStatusCode.OK, Employees);
                    }
                    return Request.CreateErrorResponse(HttpStatusCode.NotFound, "No result found");
               
            }
            catch
            {
                return new HttpResponseMessage(HttpStatusCode.InternalServerError);
            }

        }

        public HttpResponseMessage GetEmployeeById(int Id)
        {
            try
            {


                Employee emp = FetchFromDB().Where(x => x.Id == Id).SingleOrDefault();
                    if (emp != null)
                    {
                        return Request.CreateResponse(HttpStatusCode.OK, emp);
                    }
                    return Request.CreateErrorResponse(HttpStatusCode.NotFound, "Employee with id " + Id + "Not found");

                
            }
            catch
            {
                return new HttpResponseMessage(HttpStatusCode.InternalServerError);
            }
        }
		
public HttpResponseMessage GetAllEmployee()
        {
            try
            {
               
                    var Employees = FetchFromDB();
                    if (Employees != null)
                    {
                        return Request.CreateResponse(HttpStatusCode.OK, Employees);
                    }
                    return Request.CreateErrorResponse(HttpStatusCode.NotFound, "No result found");
               
            }
            catch
            {
                return new HttpResponseMessage(HttpStatusCode.InternalServerError);
            }

        }

        public HttpResponseMessage GetEmployeeById(int Id)
        {
            try
            {


                Employee emp = FetchFromDB().Where(x => x.Id == Id).SingleOrDefault();
                    if (emp != null)
                    {
                        return Request.CreateResponse(HttpStatusCode.OK, emp);
                    }
                    return Request.CreateErrorResponse(HttpStatusCode.NotFound, "Employee with id " + Id + "Not found");

                
            }
            catch
            {
                return new HttpResponseMessage(HttpStatusCode.InternalServerError);
            }
        }
		
I think now you got the point , why does HttpResponseMessage exist? yes , it is used to return data along with the Http Status code and additional error Messages.

Now Let's come to IHttpActionResult , the purpose of IHttpActionResult is exactly the same , it also serves the same purpose of returning data with http status code and additional error messages if there is any.

public IHttpActionResult Delete(int id)
{
    var status = _Repository.DeleteCustomer(id);
    if (status)
    {
        //return new HttpResponseMessage(HttpStatusCode.OK);
        return Ok();
    }
    else
    {
        //throw new HttpResponseException(HttpStatusCode.NotFound);
        return NotFound();
    }
}

//return Ok();           // Status Code 200
//return Created();      // Status Code 201 (this one requires parameters)
//return NoContent();    // Status Code 204
//return BadRequest();   // Status Code 400
//return Unauthorized(); // Status Code 401
//return Forbid();       // Status Code 403
//return NotFound();     // Status Code 404

Now, you might be thinking then why did Microsoft introduce a new return type in the form of IHttpActionResult when we already had HttpResponseMessage to serve the same purpose?

IHttpActionResult was first introduced introduced in Web API 2 that works as a return type for Action methods , this means Instead of returning HttpResponseMessage from a controller action, we can now return IHttpActionResult.Using the IHttpActionResult interface over HttpResponseMessage have many adavantages, some of them are
    1. The code becomes cleaner and easier to read, which leads to better maintainability.
    2. Unit testing controller action methods also becomes much simpler.

Consider the above EmployeeController. Notice both the Get() methods return HttpResponseMessage. To create the HttpResponseMessage, we often use CreateResponse() method of the Request objectand send the necessary data or we use CreateErrorResponse() method of the Request object to send an error response. these makes the code lengthy and could be replaced by IHttpActionResult.

Let's rewrite the above example with the help of IhttpActionResult and the helper methods, for this replace all instances of HttpResponseMessage with IhttpActionResult and to create Response, use Ok() helper method which accepts the object we want to return and create HttpResponseMessage internally it also set the status code to 200 Ok automatically.
-------------------------------
Model Binding:

ASP.NET MVC model binding allows mapping HTTP request data with a model. It is the procedure of creating .NET objects using the data sent by the browser in an HTTP request. Model binding is a well-designed bridge between the HTTP request and the C# action methods.

Data from HTTP requests are used by controllers and Razor pages. Route data, for example, may serve as a record key, while posted form fields may serve as values for model properties. It would be laborious and error-prone to write code to retrieve each of these data and transform them from strings to .NET types. This approach is made easier by model binding. The model binding mechanism is as follows:

Data is retrieved from a variety of sources, including route data, form fields, and query strings.
In method arguments and public properties, the data is passed to controllers and Razor pages.
Converts data from strings to .NET types.
Properties of complicated types are updated.

When a user performs the HTTP request with web-form data, the application request will redirect to the corresponding Controller Action method and its model. When the request transfers to the controller, the model binder will bind the request with the corresponding action method. According to this model, the binder provides the ways to bind the HTTP request with the corresponding Controller’s Action method and model. It works as an agent between View, Controller, and Model.

ASP.NET MVC implements many alternatives to bind the HTTP request (browser request or web form data) which comes /view’s data to model properties through controller action method.

Model binding
Form Collection

either:
[HttpPost]
public ActionResult Index(int student_id, string name )//these are #id in form

public ActionResult Index(IFormCollection frm )//these are #id in form
{var id= frm["student_id"].ToString();}

ModelBinding: after creating class:

[HttpPost]

public ActionResult Edit(Employee etd)

{

    var id = etd.EmpId ;

    var name = etd.StudentName;

    var EmpOrg= etd.Org;

    var Employeetype = etd.Employeetype.EmployeeTypename;

    return RedirectToAction("Index");

}


@model MVCSimpleApp.Models.Employee
@{
   Layout = null;
}

<!DOCTYPE html>
<html>
   <head>
      <meta name = "viewport" content = "width = device-width" />
      <title>Create</title>
   </head>
	
   <body>
      @using (Html.BeginForm()){
         @Html.AntiForgeryToken()
         <div class = "form-horizontal">
            <h4>Employee</h4>
            <hr />
            @Html.ValidationSummary(true, "", new { @class = "text-danger" })
				
            <div class = "form-group">
               @Html.LabelFor(model => model.Name, htmlAttributes:
                  new{ @class = "control-label col-md-2" })
						
               <div class = "col-md-10">
                  @Html.EditorFor(model => model.Name, new{ htmlAttributes =
                     new { @class = "form-control" } })
							
                  @Html.ValidationMessageFor(model => model.Name, "",
                     new{ @class = "text-danger" })
               </div>
            </div>
-------------------------------
-------------------------------
.net in SeedData in identity:
var serviceProvider=service.BuildServiceProvider();

using var scope=serviceProvider.GetRequiredService<IServiceScopeFactory>().CreateScope();
scope.ServiceProvider.GetService<PersistedGrantDbContext>().Database.Migrate();

var context=scope.ServiceProvider.GetService<ConfigurationDbContext>();
context.Database.Migrate();

EnsureSeedData(context);

var ctx=scope.ServiceProvider.GetService<AspNetIdentityDbCOntext>();
ctx.Database.Migrate();
EnsureUsers(scope);


--------------------------
Identity server(Using Identity In ASP.NET Core MVC Authentication):



--------------------------
What is Oauth?:
OAuth 2.0, which stands for “Open Authorization”, is a standard designed to allow a website or application to access resources hosted by other web apps on behalf of a user
OAuth 2.0 is an authorization protocol and NOT an authentication protocol. As such, it is designed primarily as a means of granting access to a set of resources, for example, remote APIs or user data.

OAuth 2.0 uses Access Tokens. An Access Token is a piece of data that represents the authorization to access resources on behalf of the end-user. OAuth 2.0 doesn’t define a specific format for Access Tokens. However, in some contexts, the JSON Web Token (JWT) format is often used. This enables token issuers to include data in the token itself. Also, for security reasons, Access Tokens may have an expiration date.

The idea of roles is part of the core specification of the OAuth2.0 authorization framework. These define the essential components of an OAuth 2.0 system, and are as follows:

Resource Owner: The user or system that owns the protected resources and can grant access to them.

Client: The client is the system that requires access to the protected resources. To access resources, the Client must hold the appropriate Access Token.

Authorization Server: This server receives requests from the Client for Access Tokens and issues them upon successful authentication and consent by the Resource Owner. The authorization server exposes two endpoints: the Authorization endpoint, which handles the interactive authentication and consent of the user, and the Token endpoint, which is involved in a machine to machine interaction.

Resource Server: A server that protects the user’s resources and receives access requests from the Client. It accepts and validates an Access Token from the Client and returns the appropriate resources to it


Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, including Cross-Site Scripting (XSS) and data injection attacks. These attacks are used for everything from data theft, to site defacement, to malware distribution.

To enable CSP, you need to configure your web server to return the Content-Security-Policy HTTP header. (Sometimes you may see mentions of the X-Content-Security-Policy header, but that's an older version and you don't need to specify it anymore.)

Alternatively, the <meta> element can be used to configure a policy, for example:

<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; img-src https://*; child-src 'none';" />
  

--------------------------

AddController vs AddMvc vs AddControllersWithViews vs AddRazorPages:

Support of controller is available for all the methods. So, if you need only a controller then you can use any of the methods.
The model binding feature is also available for all the methods. Model binding is used to map the incoming data to the controller action methods.
Except for the AddRazorPages method, all other methods support the API Explorer feature. The API Explorer has used the list of all the available APIs in your application.
Authorization is available for all four methods. Authorization is basically used to provide the security features,
Again, except for the AddRazorPages method, all other methods support CORS. CORS is basically a feature that allows CROSS domain call. That means from other domains they can access your method using jQuery AJAX.
The validation feature is supported by all the methods. Validation is basically used to validate the HTTP Request data. In .NET Core Application, we can implement validation using a concept called Data Annotation.
Except for the AddRazorPages method, all other methods support the Formatter Mapping feature. The Formatter Mapping feature is basically used to format the output of your action method such as JSON or XML, etc.
Antiforgery, TempData, and Views features are not available in the AddControllers method.
The Pages are available only with AddMVC and AddRazorPages method.
TagHelpers are not available in the AddControllers method and available for rest three methods.
The memory Cache feature is also not available in the AddControllers method but available with the rest three methods.

If you want to create a Web API application where there are no views, then you need to use AddControllers() extension method.
If you want to work with the Razor Page application, then you need to use the AddRazorPages() extension method into your ConfigureService method of Startup class.
If you want to develop a Model View Controller i.e. MVC application then you need to use AddControllersWithViews() method. Further, if you want Pages features into your MVC application, then you need to use the AddMVC method.

AddMvc: This method has all the features. So, you can any type of application (Web API, MVC, and Razor Pages) using this AddMVC method.
Note: Adding AddMvc() method will add extra features even though which are not required to your application which might impact the performance of the application

AddMvc is basically wrapping a call to AddControllersWithViews, with the addition of calling AddRazorPages
--------------------------
JWT Authentication

appsettings.json:

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*",
  "Jwt": {
    "Key": "DhftOS5uphK3vmCJQrexST1RsyjZBjXWRgJMFPU4",
    "Issuer": "https://localhost:44381/",
    "Audience": "https://localhost:44381/"
  }
}

// the Jwt we put
// key is generated by random online
// Issuer and Audience is obtained by right clicking the proj file inside the solution file and then going in properties then in debug an in ssl


startup.cs:

 public void ConfigureServices(IServiceCollection services)
        {
            // this is to add the authentication via JWT
            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                .AddJwtBearer(options => {
                    options.TokenValidationParameters = new TokenValidationParameters
                    {
                        ValidateIssuer = true,
                        ValidateAudience = true,
                        ValidateLifetime = true,
                        ValidateIssuerSigningKey = true,
                        ValidIssuer = Configuration["Jwt:Issuer"], //from appsettings.json
                        ValidAudience = Configuration["Jwt:Audience"],
                        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration["Jwt:Key"]))
                    };
                });
            services.AddMvc();//for including the models and views
            services.AddControllers();///for hitting the controllers
            services.AddRazorPages();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler("/Error");
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }

            app.UseHttpsRedirection();
            app.UseStaticFiles();

            app.UseRouting();

            //for using authentication api endpoints
            app.UseAuthentication();

            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                //to access the api controller
                endpoints.MapControllers();
                endpoints.MapRazorPages();
            });
userModel:

public class UserModel
    {
        public string Username { get; set; }
        public string Password { get; set; }
        public string EmailAddress { get; set; }
        public string Role { get; set; }
        public string Surname { get; set; }
        public string GivenName { get; set; }
    }
	
	
userLogin:
public class UserLogin
    {
        //pass the api username and password but this is the best practice
        public string Username { get; set; }
        public string Password { get; set; }
    }
	
//this is sort of database holder for us
        public static List<UserModel> Users = new List<UserModel>()
        {
            new UserModel() { Username = "jason_admin", EmailAddress = "jason.admin@email.com", Password = "MyPass_w0rd", GivenName = "Jason", Surname = "Bryant", Role = "Administrator" },
            new UserModel() { Username = "elyse_seller", EmailAddress = "elyse.seller@email.com", Password = "MyPass_w0rd", GivenName = "Elyse", Surname = "Lambert", Role = "Seller" },
        };
		
loginController:

//authenticate and create token
    [Route("api/[controller]")]
    [ApiController]
    public class LoginController : ControllerBase
    {
        private IConfiguration _config;

        //type ctor and double tap to create constructor
        // ctrl . to create the method showing error
        public LoginController(IConfiguration config)
        {
            _config = config;
        }

        [AllowAnonymous] // prevent the auth on this point of calling maethod because first this user will call if not logged in
        [HttpPost]
        public IActionResult Login([FromBody] UserLogin userLogin)
        {
            var user = Authenticate(userLogin);

            if (user != null)
            {
                var token = Generate(user);
                return Ok(token);
            }

            return NotFound("User not found");
        }

        private string Generate(UserModel user)
        {
            var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["Jwt:Key"]));
            var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

            //way to store data about user or process
            // storing claim types that are registered

            //the claims store info so that we dont have to go back to database to get info
            //evry time make request send the token that holds info
            var claims = new[]
            {
                new Claim(ClaimTypes.NameIdentifier, user.Username),
                new Claim(ClaimTypes.Email, user.EmailAddress),
                new Claim(ClaimTypes.GivenName, user.GivenName),
                new Claim(ClaimTypes.Surname, user.Surname),
                new Claim(ClaimTypes.Role, user.Role) //imp define some level of acsess
            };

            //api will validate issuer and audience
            var token = new JwtSecurityToken(_config["Jwt:Issuer"],
              _config["Jwt:Audience"],
              claims,
              expires: DateTime.Now.AddMinutes(15),
              signingCredentials: credentials);

            return new JwtSecurityTokenHandler().WriteToken(token);
        }

        private UserModel Authenticate(UserLogin userLogin)
        {
            var currentUser = UserConstants.Users.FirstOrDefault(o => o.Username.ToLower() == userLogin.Username.ToLower() && o.Password == userLogin.Password);

            if (currentUser != null)
            {
                return currentUser;
            }

            return null;
        }
    }
	
userController:

[Route("api/[controller]")]
    [ApiController]
    public class UserController : ControllerBase
    {

        [HttpGet("Admins")] //route will be api/user/admins
        [Authorize(Roles = "Administrator")] 
        //this specifies the level of access and you will get 403 if not
        //notation: this will authorize if valid jwt and passed alon with request
        //to use in postman generate token then goto authorization then
        //from type choose bearer token and paste the jwt token
        public IActionResult AdminsEndpoint()
        {
            var currentUser = GetCurrentUser();

            return Ok($"Hi {currentUser.GivenName}, you are an {currentUser.Role}");
        }


        [HttpGet("Sellers")]
        [Authorize(Roles = "Seller")]
        public IActionResult SellersEndpoint()
        {
            var currentUser = GetCurrentUser();

            return Ok($"Hi {currentUser.GivenName}, you are a {currentUser.Role}");
        }

        [HttpGet("AdminsAndSellers")]
        [Authorize(Roles = "Administrator,Seller")]
        public IActionResult AdminsAndSellersEndpoint()
        {
            var currentUser = GetCurrentUser();

            return Ok($"Hi {currentUser.GivenName}, you are an {currentUser.Role}");
        }

        [HttpGet("Public")]
        public IActionResult Public()
        {
            return Ok("Hi, you're on public property");
        }

        private UserModel GetCurrentUser()
        {
            var identity = HttpContext.User.Identity as ClaimsIdentity;
            //gets the identity

            if (identity != null)
            {
                var userClaims = identity.Claims;
                //grab the array of claims

                //create new user model based on the claims that we have.. registered
                return new UserModel
                {
                    Username = userClaims.FirstOrDefault(o => o.Type == ClaimTypes.NameIdentifier)?.Value,
                    EmailAddress = userClaims.FirstOrDefault(o => o.Type == ClaimTypes.Email)?.Value,
                    GivenName = userClaims.FirstOrDefault(o => o.Type == ClaimTypes.GivenName)?.Value,
                    Surname = userClaims.FirstOrDefault(o => o.Type == ClaimTypes.Surname)?.Value,
                    Role = userClaims.FirstOrDefault(o => o.Type == ClaimTypes.Role)?.Value
                };
            }
            return null;
        }
    }

2nd proj JWT:

appsetting.json:

{
  "TokenKey": "This is my test private key",
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}

startup.cs:

public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllers();
            var tokenKey = Configuration.GetValue<string>("TokenKey");
            var key = Encoding.ASCII.GetBytes(tokenKey);
            services.AddAuthentication(x =>
            {
                x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
                x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            }).AddJwtBearer(x =>
            {
                x.RequireHttpsMetadata = false;
                x.SaveToken = true;
                x.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(key),
                    ValidateIssuer = false,
                    ValidateAudience = false
                };
            });
            services.AddSingleton<IJWTAuthenticationManager>(new JWTAuthenticationManager(tokenKey));

        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseHttpsRedirection();

            app.UseRouting();
            app.UseAuthentication();
            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });
        }
    }
JWTAutheticationManager.cs:

public class JWTAuthenticationManager : IJWTAuthenticationManager
    {
        IDictionary<string, string> users = new Dictionary<string, string>
        {
             { "test1", "password1" },
             { "test2", "password2" }
        };
        private readonly string tokenKey;
        public JWTAuthenticationManager(string tokenKey)
        {
            this.tokenKey = tokenKey;
        }
        public string Authenticate(string username, string password)
        {
            if (!users.Any(u => u.Key == username && u.Value == password))
            {
                return null;
            }
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes(tokenKey);
            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(new Claim[]
            {
                new Claim(ClaimTypes.Name, username)
            }),
                Expires = DateTime.UtcNow.AddHours(1),
                SigningCredentials = new SigningCredentials(
            new SymmetricSecurityKey(key),
            SecurityAlgorithms.HmacSha256Signature)
            };
            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);

        }

NameCOntroller.cs:

[Authorize]
    [Route("api/[controller]")]
    [ApiController]
    public class NameController : ControllerBase
    {
        private readonly IJWTAuthenticationManager jWTAuthenticationManager;


        public NameController(IJWTAuthenticationManager jWTAuthenticationManager)
        {
            this.jWTAuthenticationManager = jWTAuthenticationManager;

        }

        //note: first use-> https://localhost:44345/api/Name/authenticate to geth the token
        //body: {"Username":"test1","Password":"password1"}, POST
        //then use->https://localhost:44345/api/Name in Authorization put the token then GET

        // GET: api/Name
        [HttpGet]
        public IEnumerable<string> Get()
        {
            return new string[] { "New York", "New Jersey" };
        }

        // GET: api/Name/5
        [HttpGet("{id}", Name = "Get")]
        public string Get(int id)
        {
            return "New Jersey";
        }

        [AllowAnonymous]
        [HttpPost("authenticate")]
        public IActionResult Authenticate([FromBody] UserCred userCred)
        {
            var token = jWTAuthenticationManager.Authenticate(userCred.Username, userCred.Password);

            if (token == null)
                return Unauthorized();

            return Ok(token);
        }



    }
UserCred.cs:

public class UserCred
    {
        public string Username { get; set; }
         public string Password { get; set; }
    }

--------------------------------
Status code:
Some helper methods for the most common codes (there may be more than the list below):

return Ok();           // Status Code 200
return Created();      // Status Code 201 (this one requires parameters)
return NoContent();    // Status Code 204
return BadRequest();   // Status Code 400
return Unauthorized(); // Status Code 401
return Forbid();       // Status Code 403
return NotFound();     // Status Code 404
Some of the helper methods above have overrides that allow you to include an optional response (test/json/html):

return Ok(someJson);
return NotFound("we looked but it's GONE");
Return StatusCode()
Basic return of a status code and an optional response, which can be text, json, html, etc:

return StatusCode(403)
return StatusCode(403, "some text, json, etc.");
Use StatusCodes Enum Instead of Integer
It can be really helpful to make use of the StatusCodes enum (requires using Microsoft.AspNetCore.Http;), which provides some built-in meaning to the otherwise-forgettable status code integer values. A developer who looks at your code in the future (including yourself) will be grateful to see something like StatusCodes.Status424FailedDependency instead of just 424.

return StatusCode(StatusCodes.Status403Forbidden)
return StatusCode(StatusCodes.Status403Forbidden, "some text, json, etc."); // 
--------------------------------
99
XUnit:
[Fact]
public void Test_Index_Returns_ProductCount(){
	//Arrange
	var controller=new ProductController();
	var result=(controller.Index()) as ViewResult;
	//Act
	var productList=(List<Product>?)result?.ViewData.Model;
	//Assert
	Assert.Equal(3,productList.Count);
}
[Fact]
public void Test_Details_Returns_ViewName(){
	var controller=new ProductController();
	var result=controller.Details(2) as ViewResult;
	Assert.Equal("Details",result?.ViewName);
}
[Fact]
public void Test_Details_RedirecToIndex_IfIdLessThanOne(){
	var controller=new ProductController();
	var result=(RedirectToActionResult)controller.Details(-1);
	Assert.Equal("Index",result.ActionName);
}
[Fact]
public void Test_Details_Returns_ViewData(){
	var controller=new ProductController();
	var result=controller.Details(2) as ViewResult;
	var product=result?.ViewData?.Model;
	Assert.Equal("Model",product?.ToString());
}

how to do in case on dependency injection:
private Mock<ILogger<HomeController>> _loggerMock = new Mock<ILogger<HomeController>>();
private ApplicationDbContext _db;
private Mock<IConfiguration> _configMock = new Mock<IConfiguration>();
private Mock<IHttpContextAccessor> _ctxaccMock = new Mock<IHttpContextAccessor>();

        [Fact]
        public void Test_Index_Returns_ViewName()
        {
            List<Claim> claims = new List<Claim>()
            {
                new Claim(ClaimTypes.NameIdentifier, "TestName"),
                new Claim(ClaimTypes.GivenName, "Test"),
                new Claim(ClaimTypes.Surname, "Name"),
                new Claim(ClaimTypes.Email, "Test@mail.com"),
                new Claim(ClaimTypes.Role, "Customer")
            };

            ClaimsIdentity identity = new ClaimsIdentity(claims);
            ClaimsPrincipal principal = new ClaimsPrincipal(identity);
            var httpContext = new DefaultHttpContext();
            httpContext.User = principal;

            var session = new MockSession();
            session.SetString("JwtToken", "TestJwtTokenValue");
            httpContext.Session = session;

            var optionsBuilder = new DbContextOptionsBuilder<ApplicationDbContext>();
            // Install-Package Microsoft.EntityFrameworkCore.InMemory
            optionsBuilder.UseInMemoryDatabase(databaseName: "database_name");
            _db = new ApplicationDbContext(optionsBuilder.Options);
            // Add sample data
            _db.Books.Add(new Book() { Id = 1, Name = "Test", Author = "Test", ISBN = "Test", BookGenre = "Test", BookStatus = "Test" });
            _db.SaveChanges();
            // Mock interface setups are done, create the controller now
            var controller = new HomeController(_loggerMock.Object, _db, _configMock.Object, _ctxaccMock.Object);
            controller.ControllerContext = new ControllerContext { HttpContext = httpContext }; // _ctxacc is passed as null
            //_ctxaccMock.Setup(x=>x.HttpContext.Session).Returns(session);
            //_ctxaccMock.Setup(x=>x.HttpContext.User).Returns(principal);

            //var result = controller.Index() as ViewResult;
            var result = controller.Index();
            var viewResult = Assert.IsType<ViewResult>(result);
            //Assert.Equal("Index", result?.ViewName);
            Assert.Equal("Index", viewResult.ViewName);
		}
		
		
		SEE for testing xunit
		https://code-maze.com/unit-testing-aspnetcore-web-api/
--------------------------------
Session Storage in .net server side and javascript client side:

In .NET Core, you cannot directly set session storage from a controller and access it directly via JavaScript. Session storage is a client-side feature available in web browsers, while the controller in .NET Core executes server-side.


To achieve communication between the server-side and client-side, you can use techniques like AJAX or API endpoints. Here's a general approach to set session storage from a .NET Core controller and access it via JavaScript:

services.AddDistributedMemoryCache();//To Store session in Memory, This is default implementation of IDistributedCache    
services.AddSession();  
app.UseCookiePolicy();      
app.UseSession(); 


Set the value in session from the controller:

In your .NET Core controller, you can use the HttpContext.Session property to set values in the session. Make sure you have enabled session in your application by adding the necessary services in the ConfigureServices method of Startup.cs.


public IActionResult SetSessionValue()
{
    HttpContext.Session.SetString("key", "value");
    return Ok();
}



Create an API endpoint to retrieve the session value:

Add a new action method in your controller that returns the session value as JSON or any other format suitable for your needs.


public IActionResult GetSessionValue()
{
    var value = HttpContext.Session.GetString("key");
    return Json(value);
}



Make an AJAX request in JavaScript to retrieve the session value:

In your JavaScript code, use an AJAX call to the API endpoint you created to fetch the session value.


javascript
Copy code
$.ajax({
    url: '/YourController/GetSessionValue',
    method: 'GET',
    success: function(response) {
        // Handle the response and access the session value
        var sessionValue = response;
        // Use the session value as needed
    },
    error: function(error) {
        // Handle the error
    }
});
--------------------------------
Tag Helpers:


--------------------------------


----------------------------------------------------------------------------
============================================================================
----------------------------------------------------------------------------


--------------------------------
ASP net mvc kudvenkat:

1. to get mvc version:
	1. expand references> right click System.Web.mvc> properties> VERSION;
	2. At runtime: typeof(Controller).Assembly.GetName().Version.ToString();


2. to get stuff from url:
home/index/12?name=Pulku

public string Index(string id){
	return "Id"+id + "name="+Request.QueryString["name"];//or parameter in method Index(string id, string name)
}

3. Ignore routes:
in mvc project: routes.IgnoreRoute("{resource}.axd/{*pathInfo}")
app.UseEndpoints(endpoints =>
{
    endpoints.MapGet("/favicon.ico", async (context) =>
    {
        context.Response.StatusCode = 404;
    });
    // more routing
});

OR MIDDLEWARE:

app.UseMiddleware<IgnoreRouteMiddleware>();
public class IgnoreRouteMiddleware {

    private readonly RequestDelegate next;

    // You can inject a dependency here that gives you access
    // to your ignored route configuration.
    public IgnoreRouteMiddleware(RequestDelegate next) {
        this.next = next;
    }

    public async Task Invoke(HttpContext context) {
        if (context.Request.Path.HasValue &&
            context.Request.Path.Value.Contains("favicon.ico")) {

            context.Response.StatusCode = 404;

            Console.WriteLine("Ignored!");

            return;
        }

        await next.Invoke(context);
    }
}

or
routes.MapRoute(
    name: "spa-fallback",
    template: "{*url:regex(^(?!favicon.ico).*$)}",
    defaults: new { Controller = "Home", action = "Index" })
	
routes.MapSpaFallbackRoute(
	  name: "spa-fallback",
	  defaults: new { controller = "Home", action = "Index" });

4. To get trace info:
in web.Config in MVC file:
<trace enabled="true" pageOutput="false">//for creating trace file
then:
localhost/MvcDemo/trace.axd

5. If ViewBag.CountryList=new Lisr<string>(){..} and in view ViewBag.Clist then no error on compiletime in ViewBags and ViewData i.e. no compiletime error checking
need conversion (List<string>)ViewData["key"] in ViewData 
Internally ViewBag properties are stores as name/value pairs in the ViewData Dictionary

6. for entity framework to knw which table linked in the models:
[Table("tblNameInSqlServer")]
public class Employee{...}

7. If returning a List<string> from the controller to the view then in view:
@model IEnumerable<MVCDemo.Models.Employee>

8. To generate HyperLink:
<ul>
@foreach(Employee e in @Model){
	<li>@Html.ActionLink(employee.Name,"Details",new{@id=employee.EmployeeId})</li>
}
</ul>
ActionLink(NameOnDomElement,"ActionMethod",Parameter)
ActionLink(NameOnDomElement,"ActionMethod","Controller",Parameter)
@Html.ActionLink("BackToList","Index")
@Html.ActionLink("BackToList","Index",new {departmentId=@Model.DepartmentId})
@Html.ActionLink("BackToList","Index","Controller",new {departmentId=@Model.DepartmentId})

9. return RedirectToAction("Index") to redirect to a certain action in a controller.

10. Formcollection frm object to get all the form data in [HttpPost] as keyvalue pair.

11. When using model binding in post: do:
if(ModelState.IsValid){..return RedirectToAction()}
return View()

12. If two action with same name and no parameter for get and post then compiletime error and then to fix that:
[ActionName("Create")]
public ActionResult Create_Post(){..}

13. Use of UpdateModel():
function inspects all htpprequest inputs such as posted form data, querystring, cookies and server variables and populate the employee object.
Employee emp = new Employee();
UpdateModel<Employee>(emp)

If this then no need to use params in action method

14. [required] atribute to make a field in model mandatory and:
TryUpdateModel(employee); for popping the exception if empty 
therefore:
UpdateModel() throws exception if validation fails the other doesnt

15. when we have made the name as Html.DiplayFor() then we need a Html.HiddenFor() so that we can pas along the name in the model on postback

16. To prevent fiddler from changing the model on post we use the UpdateModel():

emBusinessLayer em=new emBusinessLayer();
Employee e=emBusinessLayer.Employees.Single(x=> x.Id==id);
UpdateModel(e,new string[]{"ID","Gender","City","DateOfBirth"})//hence no name included in model binding on post form

UpdateModel(e,null,null,new string[]{"Name"}) //for excluding directly and above one is include list while this one is exclude list

17. to include exclude stuff in model binding we also use [Bind(Include="")] in the parameters of action method:
public ActionResult Edit_Post([Bind(Include="Id,Gender,City")]Employee employee){
	//set the Name property of the model binded by finding using Linq
	employee.Name=emBusinessLayer.Employees.Single(x=>x.Id==e.id).Name
	...
}

public ActionResult Edit_Post([Bind(Exclude="Name")]Employee employee)

18. To restrict binding of certain elements in form we can also use interface:
In the Interface specify only those properties that need binding and inherit this interface in the model class. 
now in the controller in the post action:
UpdateModel<IEmployee>(employee);

19. Using Get request to delete is bad: if img tag in a malicious mail. issues a delete. also search engine index your page with Get request and it would delete data.

20. for confirming on deleting:
<input type="submit" value="Delete" onclick="return confirm('del @item.Id');"/>

21. When creating entity models edmx from entityframework using multiple tables the autogenerated code might have same name of columns.
To get rid of this we can create a separate model class and inside:
[MetadataType(typeof(DepartmentMetaData))]
public partial class Department{} //same as inside the autogenerated model 
public class DepartmentMetaData{
	[Display(Name="DeptName")]
	public string Name{get;set;}
}

22. db.ObjectStateManager.CHangeObjectState(employeeFromDB,EntityState.Modified);
db.SaveChanges();

23. If we wish to add an error in model validation:
if(string.IsNullOrEmpty(employee.Name)){
	ModelState.AddModelError("Name","The Name Field is Required");
}

24. We can use data transfer object as model in mvc:
create a  DepartmentTotals.cs model class and inside have two properties:
Name and total:
now in an actionresult:
var employees = db.Employees.Include("Department")
				.GroupBy(x=>x.Department.Name)
				.Select(y=>new DepartmentTotals{Name=y.Key,Total=y.Count()}).ToList().OrderByDescending(y=>y.Total);
				
25. 2 type of viewengine:
a. ASPX
b. Razor

DIFF:
syntax: @  vs <% %>
extension: .CSHTML  vs ASPX

we can have both, just in the return View("NameOfASPX",model);

26. Order of picking up view:
a. index.aspx 
b. index.cshtml
c. index.vbhtml
d. index.ascx
nore either specify full path with extension or just the name

27.  HTML HELPERS:
@Html.TextBox("fname","John",new{style="bckcolor..",title="..."}) => <input type="text" id="fname" value="John" />
@Html.TextBox("fname","John",new{@class="red",@readonly="true"})

@Html.Label("firstname","First Name")
@Html.Password("Password")
@Html.TextArea("Comments","",5,20,null)
@Html.Hidden("id")
@Html.DropDownList("Dept",new List<SelectListItem>{
new SelectListItem{Text="IT",Value="1",Selected=true},...
},"DefaultValueToBeSelected")
@Html.RadioButtonFor(m=>m.SelectedDepartment,department.Id) @department.Name
@Html.CheckBoxFor(x=>x.IsSelected)  
@Html.TextBoxFor(m=>m.Name)
@Html.DropDownListFor(m=>m.Departments,new SelectList(Model.Departments,"Id","Name","Select dept"))

IF WE CREATE AN ENTITY MODEL OF THE TABLE WITH OPTION OF DROP DOWN LIST:
create an entity model then use that dbcontext file to fill the dropdown
SampleDBCOntext db=new SampleDBCOntext();
ViewBag.Departments=new SelectList(db.Departments,"Id","Name");
in view:: @Html.DropDownList("Departments","Select Department");
TO SELECT A DEPARTMENT: ViewBag.Departments=new SelectList(db.Departments,"Id","Name","1");

28. Editor Template for having multiple checkbox:
Create a folder in Home inside Views> EditorTemplates
The name of the view inside this folder should be same as the model name:
View name: City and ModelClass: City; Empty...

Now Inside this view:
@model MVCDemo.Models.City

@Html.HiddenFor(x=>x.ID)
@Html.HiddenFor(x=>x.Name)
@Html.CheckBoxFor(x=>x.IsSelected)
@Html.DisplayFor(x=>x.Name)

Now inside the Index view:
@model IEnumerable<MVCDemo.Models.City>
...
@using(Html.BeginForm()){
	@Html.EditorForModel() //this will look for the same view with model name
	<br/>
	<input type="submit" value="Submit"/>
}

CREATE A [HttpPost] for Index

29. StringBuilder:
StringBuilder sb=new StringBuilder();
sb.Append("something);
foreach(City city in cities){if(city.IsSelected){sb.Append(city.Name+",");}}
sb.Remove(sb.ToString().LastIndexOf(","),1);//this removes last ,
return sb.ToString();

30. 
--------------------------------

----------------------------------------------------------------------------
============================================================================
----------------------------------------------------------------------------

WEB API kudvenkat:
aasp.net web api framework to build web  apis i.e. http based services on top of .net framework

1. REST representational state transfer, CLIENT SERVER, STATELESS, CACHEABLE, UNIFORM INTERFACE, HATEOShypermediaAsTheEngineOfApplication,LAYEREDSYTSEM,CODEonDEMAND

2. When wcf(windows communication foundation) over rest:
creating services that are transport/protocol independent. Single service with multiple endpoints;; you have existing SOAP service you must support but want to add REST to reach more clients, .net 3.5 limitations
more config in wcf

3. as opposed to endpoints.MapControllerRoute(name:,pattern:,defaults:) web api has: config.Routes.MapHttpRoute(name:,routeTemplate:,defaults: new{id=RouteParameter.Optional})

public IEnumerable<string> Get(){return new string[] {"1","2"};}
public string Get(int id){return "val";}
public void Post([FromBody]string value){strings.Add(value)}
public void Put(int id,[FromBody]string value){strings[id]=value}
public void Delete(int id){stringsid.RemoveAt(id);}


4. Request Verbs: GET,PUT,POST,DELETE and also PATCH:
Request Header: contains additional info about request, what type of response is req
Request Body: contains data to send to server
Response BOdy: data sent as response from server 
Response Status codes: provide the client the status of request. 200 success, 404 not found

5. in fiddler: in the composer: Content-Type:application/json to get resonse in json  also Accept: application/json

6. Content Negotitation: in fiddler:
Accept: application/(xml,json)
Accept: application/xml,application/json
then the response will have Content-Type=application/json

IF NO Accept header then by default json
if sending to server then use Content-Type in header

7. by default the output of get that we get in fiddler is not indented:
to change that:
config.Formatters.JsonFormatter.SerializeSettings.Formatting=Newtonsoft.Json.Formatting.Indented;
and for camelcase instead of pascal case:
config.Formatters.JsonFormatter.SerializeSettings.ContractResolver= new CamelCasePropertyNamesContractResolver();

8. JaonMediaTypeFormatter and XmlMediaTypeFormatter inherit from abstract class MediaTypeFormatter. We used that above for specifying which kind of response we want
to do that:
config.Formatters.Remove(config.Formatters.XmlFormatter) //always response in json irrespective of header Accept value.
config.Formatters.Remove(config.Formatters.JsonFormatter)

9. Return Json instead of XML from web api when request made from browser:
a. config.Formatters.JsonFormatter.SupportedMediaTypes.Add(new System.Net.Http.Headers.MediaTypeHeaderValue("text/html")) //when we have text/html then jsonFormatter will be used ..but in this the returned Content-Type will still remain application.xml even though its in json 
b. WE CREATE CUSTOM JSON FORMATTER:
public CustomJsonFormatter:JsonMediaFormatter{public CustomJsonFormatter(){
	this.SupportedMediaTypes.Add(new MediaTypeHeaderValue("text/html"));
}}
public override void SetDefaultContentHeaders(Type type,HttpContentHeaders header)
{
	base.SetDefaultContentHeaders(type,headers,mediaType);
	headers.ContentType=new MediaTypeHeaderValue("application/json");
}

then
congif.Formatters.Add(new CustomJsonFormatter());

10. HttpResponseMessage to pass along statu codes int the web api methods:
public HttpResponseMessage Get(int id){
	using (EmpDbEnt ent=new EmpDbEnt()){
			var entity =ent.Employees.FirstOrDefault(e=>e.Id==id);
			if(entity!=null){return Request.CreateRespose(HttpStatusCode.Ok,entity);}
			else{
				return Request.CreateErrorResponse(HttpStatusCode.NotFound)
			}
	}
}

in post use try catch and also pass along the redirect uri:
public HttpResponseMessage Post([FromBody] Employee employee){

	try{
		using (EmpDbEnt ent=new EmpDbEnt()){
				ent.Employees.Add(employee);
				var message=Request.CreateResponse(HttpStatuCode.Created,emmployee);
				message.Headers.Location=new Uri(Request.RequestUri+employee.Id.ToString());
				}
		}
	}
	catch(Exception ex){
		Request.CreateErrorResponse(HttpStatuCode.BadRequest,ex)
	}
}

11. by default Method name should have Get.. and could be GetEmployees() getSomething() etc
we can instruct by putting [HttpGet] attribute decoration on top of method of api controller

12. if in the parameter of method we specify a string gendert="All" then this becomes an optional parameter in web api
/api/employees?gender=male

13. Parameter binding:
if param simple like int,bool,double, get val from URI(from route data or query string)
if parameter complex like Customer,Employee gets from the request body
[FromBody][FromUri]

14. Call api using jquery ajax:
$(document).ready(function(){
	$('#btn').click(function(){
		$.ajax({
			type:'GET',
			url:'api/Employees',
			dataType:'json',
			success: function(data){
				ulEmployees.empty();
				$.each(data.function(index,val){
					var fullName=val.FirstName+' '+val.LastName;
					ulEmployees.append('<li>'+fullName+'</li>')
				})
			}
		})
	})
})
to clear:
ulEmployees.empty();

15. Same Origin Policy: Browsers allow web page to make ajax req with same domain. prevents from another domain. Cross domain ajax request are restricteds
2 ways to solve:
a. Using JSONP(JSON with Padding): wraps the data in FUNCTION: CallbackFunction({"Fname":"Mark","LName":"hasting","Gender":"Male"})
var jsonpFormatter=new JsonMediaTypeFormatter(config.Formatters.JsonFormatter);
config.Formatters.Insert(0,jsonpFormatter)

$.ajax({
			type:'GET',
			url:'api/Employees',
			dataType:'jsonp',
			success:
localhost:23258/api/employees?callback=MyCallBack

b. Enabling CORS(Cross Origin Resource Sharing):
EnableCorsAttribute cors=new EnableCorsAttribute("sitesSeparatedbycommaand*forallOrigin",",separatedHeaders","method supported GET,PUT,POST *");
config.EnableCors(cors);//enable cors globally
//if for partiular controller enable cors then dont do the above code:
config.EnableCors()
in the controller:
[EnableCorsAttribute("*","*","*")]
public class EmployeeController:ApiCOntroller{
	[DisableCors] //disabe for particular method
	public ..Get()..
}

16. Enable SSL in web api:
rightclickProject>(f4 select proj)properties>SSL Enabled to true>SSl URL for https> "connection is not private">advance proceed> invalid certificate! not trusted
win+R>mmc.exe>yes>console root>file>add remove snap-in>certificates>add>computer>localcomp>ok>certificates>personal>certificates>localhost(this to be exported then imported in Trusted ROot Certification Authorities)

17. to redirect to https on entering http:
public class RequireHttpsAttribute : AuthorizationFilterAttribute
    {
        public override void OnAuthorization(HttpActionContext actionContext)
        {
            if (actionContext.Request.RequestUri.Scheme != Uri.UriSchemeHttps)
            {
                actionContext.Response = actionContext.Request
                    .CreateResponse(HttpStatusCode.Found);
                actionContext.Response.Content = new StringContent
                    ("<p>Use https instead of http</p>", Encoding.UTF8, "text/html");

                UriBuilder uriBuilder = new UriBuilder(actionContext.Request.RequestUri);
                uriBuilder.Scheme = Uri.UriSchemeHttps;
                uriBuilder.Port = 44337;

                actionContext.Response.Headers.Location = uriBuilder.Uri;
            }
            else
            {
                base.OnAuthorization(actionContext);
            }
        }
    }

then:
config.Filters.Add(new RequireHttpsAttribute());

18. Basic Authentication in WebAPi:
1. Add a new class file to EmployeeService Web API project. Name it EmployeeSecurity.cs:
using EmployeeDataAccess;
using System;
using System.Linq;

namespace EmployeeService
{
    public class EmployeeSecurity
    {
        public static bool Login(string username, string password)
        {
            using (EmployeeDBEntities entities = new EmployeeDBEntities())
            {
                return entities.Users.Any(user =>
                       user.Username.Equals(username, StringComparison.OrdinalIgnoreCase)
                                          && user.Password == password);
            }
        }
    }
}

AuthorizationFilter:

namespace EmployeeService
{
    public class BasicAuthenticationAttribute : AuthorizationFilterAttribute
    {
        public override void OnAuthorization(HttpActionContext actionContext)
        {
            if (actionContext.Request.Headers.Authorization == null)
            {
                actionContext.Response = actionContext.Request
                    .CreateResponse(HttpStatusCode.Unauthorized);
            }
            else
            {
                string authenticationToken = actionContext.Request.Headers
                                            .Authorization.Parameter;
                string decodedAuthenticationToken = Encoding.UTF8.GetString(
                    Convert.FromBase64String(authenticationToken));
                string[] usernamePasswordArray = decodedAuthenticationToken.Split(':');
                string username = usernamePasswordArray[0];
                string password = usernamePasswordArray[1];

                if (EmployeeSecurity.Login(username, password))
                {
                    Thread.CurrentPrincipal = new GenericPrincipal(
                        new GenericIdentity(username), null);
                }
                else
                {
                    actionContext.Response = actionContext.Request
                        .CreateResponse(HttpStatusCode.Unauthorized);
                }
            }
        }
    }
}

 config.Filters.Add(new RequireHttpsAttribute());

[BasicAuthentication]
public HttpResponseMessage Get(string gender = "All")
{
    string username = Thread.CurrentPrincipal.Identity.Name;

    using (EmployeeDBEntities entities = new EmployeeDBEntities())
    {
        switch (username.ToLower())
        {
            case "male":
                return Request.CreateResponse(HttpStatusCode.OK,
                    entities.Employees.Where(e => e.Gender.ToLower() == "male").ToList());
            case "female":
                return Request.CreateResponse(HttpStatusCode.OK,
                    entities.Employees.Where(e => e.Gender.ToLower() == "female").ToList());
            default:
                return Request.CreateResponse(HttpStatusCode.BadRequest);
        }
    }
}

https://www.base64encode.org/ for encoding username and password
in fiddler:
Composer:
Authorization: Basic ZmVtYWxIOmZlbWFsQ==

19. using ajax to do auth:

HtmlPage1.html in ClientApplication project.

<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8" />
    <script src="Scripts/jquery-1.10.2.js"></script>
    <script type="text/javascript">
        $(document).ready(function () {
            var ulEmployees = $('#ulEmployees');

            $('#btn').click(function () {
                // Get the username & password from textboxes
                var username = $('#txtUsername').val();
                var password = $('#txtPassword').val();

                $.ajax({
                    type: 'GET',
                    // Make sure to change the port number to
                    // where you have the employee service
                    // running on your local machine
                    url: 'http://localhost:35171/api/Employees',
                    dataType: 'json',
                    // Specify the authentication header
                    // btoa() method encodes a string to Base64
                    headers: {
                        'Authorization': 'Basic ' + btoa(username + ':' + password)
                    },
                    success: function (data) {
                        ulEmployees.empty();
                        $.each(data, function (index, val) {
                            var fullName = val.FirstName + ' ' + val.LastName;
                            ulEmployees.append('<li>' + fullName + ' (' + val.Gender + ')</li>')
                        });
                    },
                    complete: function (jqXHR) {
                        if (jqXHR.status == '401') {
                            ulEmployees.empty();
                            ulEmployees.append('<li style="color:red">'
                                + jqXHR.status + ' : ' + jqXHR.statusText + '</li>')
                        }
                    }
                });
            });

            $('#btnClear').click(function () {
                ulEmployees.empty();
            });
        });
    </script>
</head>
<body>
    Username : <input type="text" id="txtUsername" />
    Password : <input type="password" id="txtPassword" />
    <br /><br />
    <input id="btn" type="button" value="Authenticate and Get Employees" />
    <input id="btnClear" type="button" value="Clear" />
    <ul id="ulEmployees"></ul>
</body>
</html>

19.1. if two get methods: then attribute routing
[Route("api/students/{id}/courses")]
public IEnumerable<string>GetStudenCourses(int id){}

19.2.  if every method has api/students then use RoutePrefix:
[RoutePrefix("api/students")]
public class StudentsController:ApiController{..[Route("{id}")]}

19.3 if there is a method with api/teachers then we have to override the controller RoutePrefix:
[Route("~api/teachers")] //if not then api/students/api/getteachers
public GetTeachers()..

19.4 if there are multiple methods with same name but diff params we can use Routing Constraints:
[Route("{name:alpha}")]
Get()
[Route("{id:int}")]
Get()
few other: {x:min(0)}{x:max(100)}{x:length(3)}{x:length(1,10)}{x:minlength(1)}{x:maxlength(100)}{x:range(1,100)}

19.5 when creating we need to send the link to get the new object created:
[Route("{id:int}", Name = "GetStudentById")]
public Student Get(int id)
{
    return students.FirstOrDefault(s => s.Id == id);
}
public HttpResponseMessage Post(Student student)
{
    students.Add(student);
    var response = Request.CreateResponse(HttpStatusCode.Created);
    response.Headers.Location = new
        Uri(Url.Link("GetStudentById", new { id = student.Id }));
    return response;
}

19.6 IHttpActionResult vs HttpResponseMessage:
WebApi2
cleaner code;
Ok(students)
NotFound(); -> Content(HttpStatuCode.NotFound,"StudentNotFound")
BadRequest()
InternalServerError()
Created()
CreatedAtRoute() 

19.7 WebAPI versioning: once made public diff clients use n rely, business grows and req change services need change w/o breaking existing clients and satisfy new clients.
URI: have StudentsV1 model and StudentsV1Controller, so:
config.Routes.MapHttpRoute(name:"Version1",routeTemplate:"api/v1/students/{id},defaults:new{id:RouteParameter.Optional,cotroller="StudentsV1"}")
ALSO done by attribute routing: [Route("api/v2orv1/students")] //in diff controller

QueryString:
/api/students?v=1	Version 1 Students
/api/students?v=2	Version 2 Students

namespace WebAPI.Custom
{
    // Derive from the DefaultHttpControllerSelector class
    public class CustomControllerSelector : DefaultHttpControllerSelector
    {
        private HttpConfiguration _config;
        public CustomControllerSelector(HttpConfiguration config) : base(config)
        {
            _config = config;
        }

        public override HttpControllerDescriptor
            SelectController(HttpRequestMessage request)
        {
            // Get all the available Web API controllers
            var controllers = GetControllerMapping();
            // Get the controller name and parameter values from the request URI
            var routeData = request.GetRouteData();

            // Get the controller name from route data.
            // The name of the controller in our case is "Students"
            var controllerName = routeData.Values["controller"].ToString();

            // Default version number to 1
            string versionNumber = "1";
            var versionQueryString = HttpUtility.ParseQueryString(request.RequestUri.Query);
            if (versionQueryString["v"] != null)
            {
                versionNumber = versionQueryString["v"];
            }

            if (versionNumber == "1")
            {
                // if version number is 1, then append V1 to the controller name.
                // So at this point the, controller name will become StudentsV1
                controllerName = controllerName + "V1";
            }
            else
            {
                // if version number is 2, then append V2 to the controller name.
                // So at this point the, controller name will become StudentsV2
                controllerName = controllerName + "V2";
            }

            HttpControllerDescriptor controllerDescriptor;
            if (controllers.TryGetValue(controllerName, out controllerDescriptor))
            {
                return controllerDescriptor;
            }

            return null;
        }
    }
}

config.Services.Replace(typeof(IHttpControllerSelector),
    new CustomControllerSelector(config));
	
config.Routes.MapHttpRoute(
    name: "DefaultRoute",
    routeTemplate: "api/{controller}/{id}",
    defaults: new { id = RouteParameter.Optional }
);

VERSION HEADER:
in fiddler:
X-StudentService-Version:1 //then v1 else v2:
namespace WebAPI.Custom
{
    public class CustomControllerSelector : DefaultHttpControllerSelector
    {
        private HttpConfiguration _config;

        public CustomControllerSelector(HttpConfiguration config) : base(config)
        {
            _config = config;
        }

        public override HttpControllerDescriptor
            SelectController(HttpRequestMessage request)
        {
            var controllers = GetControllerMapping();
            var routeData = request.GetRouteData();

            var controllerName = routeData.Values["controller"].ToString();

            // Default the version number to 1
            string versionNumber = "1";

            // Comment the code that gets the version number from Query String
            // var versionQueryString = HttpUtility.ParseQueryString(request.RequestUri.Query);
            // if (versionQueryString["v"] != null)
            // {
            //     versionNumber = versionQueryString["v"];
            // }

            // Get the version number from Custom version header
            // This custom header can have any name. We have to use this
            // same header to specify the version when issuing a request
Note        string customHeader = "X-StudentService-Version";
            if (request.Headers.Contains(customHeader))
            {
                versionNumber = request.Headers.GetValues(customHeader).FirstOrDefault();
				if(versionNumber.Contain(",")){versionNumber=versionNumber.Substring(0,versionNumber.IndexOf(","));//to get the first}
            }

            HttpControllerDescriptor controllerDescriptor;
            if (versionNumber == "1")
            {
                controllerName = string.Concat(controllerName, "V1");
            }
            else
            {
                controllerName = string.Concat(controllerName, "V2");
            }

            if (controllers.TryGetValue(controllerName, out controllerDescriptor))
            {
                return controllerDescriptor;
            }

            return null;
        }
    }

}


ACCEPT HEADER: Accept header tells server what file format the browser wants the data. These files format are more commonly called as MIME(Multipurpose Internet mail Extension):
in fiddler:
Accept: application/json;version=1
//in above: 
var acceptHeader=request.Headers.Accept.Where(a=>a.Parameters.Count(p=>p.Name.ToLower()=="version")>0);
if(acceptHeader.Any()){versionNumber=acceptHeader.First().Parameters.First(p=>p.Name.ToLower()=="version")}
if(versionNumber=="1"){..

MEDIA TYPE: 
in fiddler:
Accept:application/vnd.pragimtech.students.v1+json:

string regex =
                @"application\/vnd\.pragimtech\.([a-z]+)\.v(?<version>[0-9]+)\+([a-z]+)";

            // Users can include multiple Accept headers in the request.
            // Check if any of the Accept headers has our custom media type by
            // checking if there is a match with regular expression specified
            var acceptHeader = request.Headers.Accept
                .Where(a => Regex.IsMatch(a.MediaType, regex, RegexOptions.IgnoreCase));
            // If there is atleast one Accept header with our custom media type
            if (acceptHeader.Any())
            {
                // Retrieve the first custom media type
                var match = Regex.Match(acceptHeader.First().MediaType,
                    regex, RegexOptions.IgnoreCase);
                // From the version group, get the version number
                versionNumber = match.Groups["version"].Value;
            }

            HttpControllerDescriptor controllerDescriptor;
            if (versionNumber == "1")...


20.  TOKEN BASED AUTHENTICATION owin(open web interface for .net) middleware and identity(THIS WILL HAVE LOGIN LOGOUT):

[Authorize] attribute requires acces token in authorization header with every request

https://www.youtube.com/watch?v=gkWb7yQb6ro&list=PL6n9fhu94yhW7yoUOGNOfHurUE6bpOO2b&index=20&pp=iAQB
ONWARDS (SEE)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



----------------------------------------------------------------------------
============================================================================
----------------------------------------------------------------------------
ASP.NET Core KUDVENKAT:


===========================
===========================
===========================

PROJECT STRUCTURE?!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

webapi vs restapi?
how change flag?

return big file?
action filter
authentication and authorization in your project
LAYERS IN YOUR PROJECT
from body? what else? WHAT IF NO CLASS
viewcomponent
ascx?? partial view?
what all return types
middleware vs actionfilter
exceptionfilter and alternative?
blazor page?
mvc
Views in .net types of pages 
better how attribute routing vs conventional routing
API AUTHENTICATE






::: code ex: for UPDERT
[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult Upsert()
{
    if (ModelState.IsValid)
    {
        if (Book.Id == 0)
        {
            //create
            _db.Books.Add(Book);
        }
        else
        {
            _db.Books.Update(Book);
        }
        _db.SaveChanges();
        return RedirectToAction("Index");
    }
    return View(Book);
}



